# 第二章：选择器

- `+` ，相邻兄弟选择器，它选中两个响铃兄弟元素的第二个元素，两个元素中间有文本内容不会影响该选择器起作用。

### 伪类:

浏览器提供的能够区分元素不同状态的类。

- 如 `:link` `:visited` `:hover` `:active` `:chekced` `:focus` 等

### 伪元素:

能够在文档中插入假想的元素，它可能只是指定一种状态。

- 如 `:first-letter` `:first-line` `:before` `:after`

css2中  `:first-letter` `:first-line` 只能用于标记或段落之类的块级元素，无法用于超链接等行内元素，css2.1 中  `:first-letter` 能应用到所有元素，但是应用的 css 属性还有所限制，见 P66

** 提示：伪类和伪元素都是与当前选择的元素相关联，可能通常认为 `p:first-child` 之类的选择器会选择 p 元素的第一个子元素，然而并不是这样，伪类的实质是把某种假想的类关联到与伪类相关的元素 **

# 第三章：层叠和结构

选择器特殊性：

- ID > class|属性|伪类 > 元素|伪元素

继承不会向上传播，但是唯一例外的时 body 的背景样式会传播到 html 元素。

通配符特殊性为 0，继承无特殊性。 所以通配符优先于继承的值:

```html
<style media="screen">
  * { color: red }
  h1#page-title{ color: blue }
</style>
<body>
  <!-- em 内的 Central 的颜色依然显示为通配符的 red -->
  <h1 id="page-title">Meerkat<em>Central</em></h1>
</body>
```

由于如果特殊性和权重等其他因素都相同的情况下，会按照出现的顺序来选择样式的优先级，所以建议按照 LVHA（link-visited-hover-active，现在改为 link-visited-focus-hover-active） 的顺序来什么链接样式：

```css
:link{ color: blue; }
:visited{ color: purple; }
:hover{ color: red; }
:active{ color: orange; }
```
因为如果按照下面的顺序，将永远不会显示 `:hover` 和 `:active`：

```css
:active{ color: orange; }
:hover{ color: red; }
:link{ color: blue; }
:visited{ color: purple; }
```
由于它们权重都相同，所以出现在后面的就会有较高的优先级。链接要么为未访问，那么就显示 `:link`，要么就为已访问，显示 `:visited`；`:active` 和 `:hover` 就被这两个属性给覆盖了。

**提示：除了按顺序，还可以增加特殊性，如 `:hover:link { color: red; }`**

# 第四章：值和单位

在CSS中，**相对 URL 要相对于样式表本身，而不是相对于使用该样式表的 HTML 文档**。

例如根目录有一个 index.html，它 link 了 css 目录下面的样式表文件，该样式表定义了一个元素背景图片位置，该图片位于根目录下的 pic 目录里，则这个 url 应该为 `../pic/图片名`， **道理很简单，如果我们是引用的公共 CDN 提供的样式表，那么撰写这个样式表的作者并不知道会被哪些人在什么地方的 HTML 文件中引用，他所能知道的仅仅是按照他当前的样式表文件来引用外部图片** ，否则不同的页面引用相同的外部样式，那么就完全无法预知图片的位置。（P97）

**提示：url 和开始括号 `(` 之间不能有空格，否则将导致整个声明都无效**

# 第五章：字体

### 字体系列：

它们并不是指定一种字体，而是指一类字体，这类字体有它们自己的共性：

- Serif：有上下短线
- Sans-serif：没有上下短线，感觉就像中文的黑体
- Monospace：字符间距相同，如 i 和 m 所占用的宽度一样
- Cursive：书上说是该字体试图模仿人的手写体，在 mac 上测试，和 Serif 没有什么差别，只是字体宽度要大一点。
- Fantasy：这一类字体无法用任何特征来定义

使用 `font-family` 指定字体顺序的时候，如果字体名带有空格和符号，应包含在引号内，通用字体系列名不能加引号，否则会被当做特定的字体而非字体系列对待。

### 字体加粗：

字体的粗细度从 100 ~ 900，梯度为 100，分别对应字体粗细的 9 个等级。但是一般字体可能只实现了其中的部分粗细等级，而没有完全实现 9 个等级，所以浏览器就会对它们进行映射：根据字体实现了的等级进行划分，`normal` 对应 400，`bold` 对应 700，**而 `bolder` 首先获取从父级继承的 `font-weight` 的值，然后取下一个对应的能看出加粗效果的等级，但无论如何都超不过 900** ，即便是计算下来的结果超过了 900 也会被替代为 900，因为它已经是最粗的等级，如果没有更粗的等级，则取下一级，如 700 已经达到该字体最粗等级，那么 `bolder` 将会是 800，`lighter` 与 `bolder` 相反。（具体规则参考 P107）

### 字体大小：

`font-size`

实际上，`font-size` 属性与你看到的实际字体大小之间的关系由字体的设计者来确定。这种关系设置为字体本身中的一个 em 方框。这个 em 方框不一定指示字体中字符建立的任何边界，它指示如果没有额外的行间距（line-height）时基线间的距离。某种字体的字符可能比默认的基线间距要高，这是完全有可能的。（P114）因此，font-size 的作用是为给定字体的 em 框提供一个大小，而不能保证实际显示的字符就是这种大小。

类似于 `bolder` `lighter`，字体大小也有 `larger` `smaller`，另外字体大小还有7个绝对大小关键字：`xx-small` `x-small` `small` `medium` `large` `x-large` `xx-large`，这些关键字并没有明确的定义，而是相对来定义的。另外，字体大小并没有限制，`larger` 完全可以大于 `xx-large`，这很明显，因为我们可以通过像素值来将字体指定为任意我们希望的值，Chrome 将最小值限制为 12px（可借助 CSS 的 transform 缩放将字体缩小到 12px 以下），其他浏览器则可能没有这种限制。

百分数值总是根据从父元素继承的大小来计算的，并且 **继承的值是计算过后得到的值，而非百分数值**，例如父元素是 24px，当前元素如果是 80% 那么就是 `24 * 80%` 得到 19.2px，它的子元素如果也是 80 % 那么得到的可能是 `19.2 * 80%` 也可能是 `19 * 80%`，这取决于不同的浏览器实现。

`font` 的声明必须包含 `font-size` 和 `font-family`，并且 font-size 必须在前面，font 规则的前三个属性（`font-style` `font-variant` `font-weight`）位置可以采用任意顺序。font 可以指定行高 `line-height`，它和 font-size 合并写在一起，并使用 `/` 分隔，并且 font-size 必须在前面。（个人建议如果不清楚 font 的规则应尽量避免直接使用 font）

一个 font 的例子：

```css
h2 { font: bold italic 200%/1.2 Verdana, Helvetica, Arial, sans-serif; }
```

# 第六章：文本属性

### 文本缩进：

`text-indent`

可继承，所以只对块元素有效，对行内元素无效，对图像等替换元素也无效。行内元素可以用左右margin或者padding达到缩进的效果。

它可以使用所有的长度单位，如果使用百分数，则是相对于父元素的宽度来计算，如 `10%` ，则取父元素宽度的 `10%` 作为缩进。该元素会继承。

将该属性用于块元素，它内部的内联元素会显示出缩进。该属性可能使得缩进的元素的内容超出起父元素的范围或浏览器范围，它可以无限缩进而不会将浏览器或者父元素撑开。缩进行的第一个单词或者元素始终会出现在该行，而它后面的元素会在父元素的宽度范围内换行（将一个块元素的 `text-indent` 属性无限加大可以发现该效果，可能对缩进的处理实际上只是缩进第一个单词或者元素，它后面的元素跟在它后面正常顺延）。

### 水平对齐

`text-align`

只能用于块元素

除了 `left` `center` `right` 之外还有 `justify`，它会强制每一行的首尾与行的边界对齐，如果在行尾出现半个单词的情况，它会将该单词显示在下一行，而根据浏览器自身的实现来拉伸或压缩本行字符间距或者单词间距来促使左右边界对齐。

如果 letter-spacing 是一个长度值, 则不会被 justify 覆盖, word-spacing 可能被覆盖.

tip: **需要注意的是，在实践中发现，justify 的最后一行不会被拉伸到父元素两端对齐, 即对不换行的元素使用 justify 不起作用，所以需要让它换行, 有如下实现**

```css
.justify{
  width: 120px;
  text-align: justify;
}

// 使用 after 的 padding 强制将 after 内容换到下一行，触发 justify 效果
.justify:after{
  content: "";
  padding-left: 100%;
  display: inline-block;
}
```

### 垂直对齐

`line-height`

该属性是指定文本行基线(`x-height`)之间的距离，它与字体大小之差就是行间距。（line-height指定了行框最低高度，font-size指定了内容区高度）

`line-height` 实际上只影响行内元素和其他行内内容，对块级元素使用，也只能作用于它里面的行内元素，如果它里面没有行内内容，则没有效果，因为没有可以作用的元素。

在用于块级元素时，`line-height` 定义了它里面的文本行（文本也算行内元素，line-height实际上影响它里面的行内元素而不会影响块级元素，块级元素里面没有内容时line-height不会有任何效果）基线之间的 **最小** 距离，而不是一个绝对值，基线距离可能比 `line-height` 大。 **`line-height` 不影响替换元素布局** ，不过确实可以应用到替换元素。

根据CSS规范，在块级元素上面声明 line-height 会为块级元素的内容设置一个最小行框高度，从理论上讲，只有行内元素的内容才会继承这个行高，所以可以理解为为匿名文本添加虚拟行内元素来包裹块级元素内的文本（这样就把块级元素内的直接文本也当做行内元素来布局）。

每个文本行的文字都会生成一个内容区，由其中的字体大小决定。内容区会生成一个行内框（每个元素的内容区都会生成自己的行内框），如果不存在其他因素，这个行内框就完全等于该元素的内容区，然而 `line-height` 就可以增加或者减少行内框的高度。`line-height` 与内容区之间的差值会平分到内容区的顶部和底部来生成行间距，最后行框的高度就需要包含所有文字中最高的行内框和最低的行内框（示例图查看 P142）。

- **缩放因子** ：给 `line-height` 指定一个纯数字（不带单位）
由于 `line-height` 会继承，当一个块元素从另一个块元素继承 `line-height` 时，它的值会从父元素计算，而非在子元素上计算（因为继承之前就会将相对值计算为像素值），可能这个值对子元素来说并不合适，所以此时可以将 `line-height` 设置为一个数，这个数会被该元素以及它的子元素当做缩放因子并与自己的 font-size 相乘来计算出自己的 `line-height` 值。

### 垂直对齐文本

`vertical-align`

`vertical-align` 只适用于 **行内元素和替换元素（如图像或表单输入元素）** ，并且不继承。所有的垂直对齐元素都会影响行高，因为行框需要足以包含最高行内框顶端和最低行内框底端。

`vertical-align` 只接受 8 个关键字、一个百分数或一个长度值。

- `baseline`
  - 它是 `vertical-align` 的默认值。它要求元素的基线与父元素的基线对齐，这样看起来所有文本元素的底端都是对齐的。如果没有基线（如图像或者一些替换元素），则将该元素底端与父元素的基线对齐。

- `super、sub`
  - `super` 是上标，它将行内元素的基线（或替换元素的底端）相对于父元素的基线的向上提升，具体提升多少根据浏览器而异，不会改变元素的字体大小。sub 则是下标。

- `bottom`
  - 将元素的行内框的底端与**行框的底端**对齐。行内框包含文字的内容区和行间距，所以对文字应用 `bottom` 和 `top` 没有明显效果，因为它的行内框跟行框下边界都是重叠在一起的。

- `text-bottom`
  - 该关键字是指行内文本的底端，而非行框底端（行框底端由 bottom 指定），增加line-height 比较容易看出效果，该行内文本的高度即 `font-size` 指定的大小。(P147)

- `top`
  - 与 `bottom` 相反

- `text-top`
  - 与 `text-bottom` 相反

- `middle`
  - `middle` 会把行内元素的中点与父元素基线上方 `0.5ex`（`ex`指所用字体中小写 x 的高度，这里 1ex 相对于父元素的 `font-size` 定义，浏览器可能把 1ex 方便的假设为 0.5em）处对齐。因为大多数浏览器把 1ex 处理为 0.5em，所以 `middle` 就在父元素的基线上方 0.25em 的地方对齐（不过有的浏览器确实会为各个元素精确计算 x-height）。(P148)

- 百分数（相对于 **自身** 的`line-height` 而非 `font-size`）
  - 该值会将元素的基线（或替换元素的底边）相对于父元素基线升高或者降低指定的量，这个量为 `该元素 line-height * 指定的百分数`，而非相对于父元素的 `line-height`（内联元素不会响应 line-height，但是却可以用于 `vertical-align` 的计算）。正百分数使得元素基线升高，反之则降低。

- 长度值
  - 如 5px 则将元素升高 5 像素。负值使元素下降。

### 字、字母间隔

`word-spacing` 和 `letter-spacing`

它们的默认关键字 `normal` 都相当于 0；它们都会继承，但是无法为它们指定一个可继承的缩放因子，因此如果需要的效果不是继承值的效果，则需要显示指定它们的值。

`word-spacing` 是以空白字符进行区分的，所以它可能是非空白字符组成的字符串，像中文段落这种就可能达到的不是我们想要的效果了。所以要慎用。

`letter-spacing`

### 文本转换

`text-transform`

默认值为 `none`，对文本不做任何改动。

- `uppercase`: 全部转为大写
- `lowercase`：全部转为小写
- `capitalize`：单词首字母大写（对于 "Heading-one" 这一类此，根据浏览器的实现可能只对第一个单词首字母大写，也可能两个单词首字母都大写，CSS并没有规定哪一种正确）
- `inherit`

### 文本装饰

`text-decoration`

默认为`none`，关闭所有装饰。装饰线的颜色与文本颜色相同。该属性不会继承，而且也不可以取消父元素的装饰线，因为父元素的装饰线会穿过子元素，因为是父元素的装饰线，所以颜色也是父元素的颜色，可能与子元素自身颜色不一样，可以对子元素单独设置以覆盖显示父元素的装饰线。可以多个值同时存在。

- `underline`
- `overline`
- `line-through`
- `inherit`
- `blink`：闪烁，很少浏览器支持。

### 文本阴影

`text-shadow`

每个阴影都由一个颜色值和 3 个长度值来定义，前两个长度值确定了阴影与文本的偏移距离，右、下为正，左、上为负值。第三个长度值为模糊半径，它为从阴影轮廓到模糊效果边界的距离，不指定该值则表示该偏移上的阴影不需要模糊。

多个阴影值之间用逗号隔开。

示例：

```css
div { text-shadow: 0 0 4px black;}
p { text-shadow: 5px .5em green, -1em -1em silver;}
```

### 处理空白符

`white-space`

默认值为 `normal`，默认情况下，浏览器会将换行符转换为空格，多个空格合并为一个空格。

- pre：类似于 `<pre>` 标签，不会对回车和空格进行处理，也不允许自动换行。
- nowrap：防止文本换行，除非使用 `<br>` 标签换行。
- pre-wrap：会保留空白符（换行符、空格等），并且文本能够正常换行。
- pre-line：保留换行符，但是会合并空格

| 值 | 空白符 | 换行符 | 自动换行 |
| :--- | :--- | :--- | :--- |
| pre-line | 合并 | 保留 | 允许 |
| normal | 合并 | 忽略 | 允许 |
| nowrap | 合并 | 忽略 | 不允许 |
| pre | 保留 | 保留 | 不允许 |
| pre-wrapo | 保留 | 保留 | 允许 |

# 第七章：基本视觉格式化

### 基本框

`外边距` > `边框` > `内边距` > `内容区`

**边框颜色默认取内容区前景色** ，如果边框没有设置颜色，则与装饰线（text-decoration）一样，默认取元素内容的前景色。

**边框拥有和内容区相同的背景颜色** ，如果边框出现缝隙（能看到边框背景的情况下，如 dashed），那么就能很清晰的看到这个效果。

行内非替换元素的外边距、边框、内边距在垂直方向上没有效果，在水平方向上才会起作用，如 span 的 margin-left 起效果，但是 margin-bottom 不起效果。

### 包含块

对于正常文本流中的元素，包含块就是一个元素的“布局上下文”，每个元素都相对于其包含块摆放。

如何确定包含块：（这里只是一部分规则，后面章节会涉及到其它规则）

包含块由最近的 **块级祖先框、表单元格、行内块祖先框的内容边界** 构成。

不用担心行内元素，因为它们的摆放方式并不直接依赖于包含块。后面章节有所讨论。

#### 术语：

- 正常流
  - 大多数元素都在正常流中，要让一个元素不在正常流中，唯一的办法就是使之成为 **浮动** 或 **定位** 元素。
- 非替换元素
  - 元素的内容包含在文档中，则称之为非替换元素
- 替换元素
  - 元素作为其它内容的一个占位符，例如 `<img>` 只是一个图片的占位符，`input` 实际上会被替换为一个输入框。
- 块级元素
  - 会在其框前和框后生成“换行”，通过 `display: block` 使元素生成块级框。
- 行内元素
  - 元素不会在前后生成“行分隔符（即换行）”，通过 `display: inline` 让一个元素生成行内框。
- 根元素
  - 文档顶端元素，在HTML 文档中就是 html 元素，XML 中可以是该语言允许的任何元素。

tip: **完整的框模型参考 P168**

### 水平格式化

对元素设置 width 属性，默认情况下这个值会被应用于元素的内容区。而元素的实际宽度还包括了内边距、边框、外边距这些，它们都会影响元素实际占用的宽度值。

水平方向只有元素的左右外边距、内容区的 width 可以设置为 auto，对于从左向右读的语言强制 margin-right 为 auto，从右往左读的语言与之相反。

width、 margin-left、 margin-right 这三个值中, 如果某一个或者两个为 auto, 则余下的会自动计算以适应父元素宽度, 过分受限会强制 margin-right 为 auto, 如果某个外边距和 width 都设置为 auto, 则外边距缩减为 0, 而 width 刚好包裹内容. 如果 3 个都为 auto, 则 margin 为 0, width 尽可能宽 

水平方向上的 7 个水平属性总和要等于父元素的 width，因此，如果外边距出现负的情况，那么元素 width 为 auto 值时可能超过父元素的 width，但总和（正负相抵）还是等于父元素的 width。如果元素 width 超过父元素 width，并且声明 margin-right 为 auto，那么该值会变成负数来满足总和不超过父元素 width 这个要求。如果不设置，它就为 0，另外从左往右的语言中，即便是这种情况，设置 margin-left 为 auto ，它也为 0 而不会出现负。

#### 百分数

边框不能使用百分数。

width、内外边距设置为百分数是参照父元素的 width 来计算的。

#### 替换元素

- 宽度为所替换元素宽度：
  - 非替换块元素的所有规则也同样适用于替换块元素，只有一个属性例外，那就是 `width: auto;`，它会变成元素的固有宽度，如对一个 `<img>` 标签，通过 `display: block;` 指定其生成块级框，并指定 `width: auto;`，那么它的宽度就是所替换的图像的原始宽度。

tip: **还需要注意，如果一个替换元素的 width 不同于其固有高度，那么它的 height 值也会成比例变化，除非显式给 height 设定了一个特定值**

### 垂直格式化

垂直格式化类似于水平格式化

- 它的 margin、padding 百分比依然是相对于父元素的 **width**
- height 相对于父元素的 height

负的外边距会使替换元素的行内框小于正常大小.

垂直 margin、border、height、padding 的值必须等于包含块的 height

如果父元素 height为auto，那么对子元素设置任何百分数高度，都相当于没有设置高度，子元素依然采用自己的高度。

但是会出现下面的问题：

如果 **正常流** （正常流中垂直相邻外边距会合并）中给一个块元素的 margin-top 或者 margin-bottom 为 auto，那么它会自动计算为 0（这一点跟水平方向一样），但是，如果为 0，那就不能很容易的将正常流元素在其包含块中垂直居中。 对于定位元素来说, 则会居中.

如果块级正常流元素高度为 **auto**，而且只有块级子元素(或上下都是块级元素)，则其默认高度将是从最高块级子元素的上外边框边界到最低子元素下外边框的边界，而子元素的外边距会超出父元素的内容区（或与父元素的margin进行重叠），如果父元素有边框或者 padding 值，那么会将子元素的 margin 也包含在它里面。 **如果父元素的高度不为 auto, 则上下 margin 不会超出, 至少不会对外面的元素造成影响.**

#### 合并垂直外边距

垂直方向上的外边距会合并，多个外边距也是会合并为最大的一个。

个人在chrome中测试发现，如果给父元素指定了固定高度，那么内部的块元素无论有多大的边距、无论高度多高、无论超出父元素多少，都不会影响到外面的元素。只有在父元素 height 为 auto 的时候，才会叠加 margin。

负的 margin 会使得元素看起来被上拉（上负外边距）或者下拉（下负外边距）了，这种效果也会使得父元素看起来也被上拉或者下拉了。下面的例子加上背景颜色效果更明显：
- 如果元素上外边距为负数，那么该元素后面的元素也会跟着它被往上拉，同时父元素也被往上拉，父元素后面的元素也会一直跟着往上跑。
- 如果元素下外边距为负数，不断的减小该外边距，那么该元素后面的元素会相对于该元素不停地往上拉，但是该元素位置不变，父元素高度不断缩小最终至 0，父元素的后面的元素也会停止在父元素为 0 的地方。

span 元素有边框的话, 会看到多行边框重叠的情况. 因为边框实际上是画在各行之外的下一个像素上.

#### 基本术语和概念 P188

- 匿名文本
  - 所有未包含在行内元素中的字符串，包括空格。如 `<p> I'm <em>so</em> happy！ </p>` 中 "I'm" 和 "happy!" 以及没包含在 em 中的空格都是匿名文本。
- em 框
  - 在字体中定义，也成为字符框，实际的字形可能比它的em框更高或者更矮。font-size 确定了各个 em 框的高度。


。。。

内外边距、边框不影响行内元素的垂直方向，不会影响行高。但是会影响行内元素的水平方向。

#### 行内替换元素 (p200)

行内替换元素的内外边距、边框会影响行框的高度，但是行内非替换元素则不会影响行框的高度。替换元素没有自己的基线，所以相对来讲最好的办法就是将其行内框的底端与基线对齐。

#### 改变元素的显示

`display`

display 只是改变了元素的显示，并没有改变元素的本质，让一个段落生成行内框并不会把这个段落真正变成一个行内元素。

- `inline-block`
  - 行内块元素，它实际上**会被作为替换元素放在行中，所以说它的底端默认位于文本行的基线上**。如果行内块元素没有定义width或者显示声明为 auto，则元素框会收缩以适应内容，也就是像 span 那样将内容放在一行（除非太长而换行）
- `run-in`
  - 如果它后面接的是一个块级框时，该 run-in 元素将成为后面那个块级框开始处的一个行内框，但是与实际上通过 span 写在后面块级框内有所不同，它是根据自身的父节点继承属性，而不是继承自紧随它后面的块级框，如果后面不是块级框，则该 run-in 元素自己生成块级框。（P209）


# 第九章：颜色和背景

前景色包括文字颜色和边框颜色。

`background-position`

如果是百分数，则该图像从左上角开始算起的百分比对应的点与包含该图像的元素对应的百分点对齐。即如果是 `background-position: 30% 20%;` 就是图像水平 30% 与 垂直 20% 这个位置的点与包含它的元素的水平 30% 垂直 20% 的点对齐。

它的起点是相对于元素内边距边界开始放置图像，不过完全平铺的图像会填充边框的背景，但是边框的背景是图像重复导致的，图像起点是从内边距左上角开始，边框处于内边距之外，它与内边距边界相邻，但是却是新的repeat的图像，如果设置 no-repeat，则边框不会有背景图像。

背景图像如果是相对于父元素居中的，那么它的重复在各个方向都裁剪得很一致，因为左右上下超出部分都一致。但是如果是默认的处于左上角开始重复，那么裁剪就不一定一致，因为右边和下边被裁剪的部分都是依据包含背景图像的元素的宽和高来决定的。

#### 关联

`background-attachment`

- scroll
- fixed
  - 如果设置为 fixed，那么该背景不会随着文档滚动，原图像的放置由可视区大小确定，即相对于可视区居中或者处于可视区的左上角，而非相对于包含元素进行布局， **但是只会在包含元素的范围内显示，超出包含元素部分会被隐藏** (P283)

# 第十章：浮动和定位

浮动元素会生成块级框，虽然可以指定它的 `display:block;`，但是没有意义。

浮动元素可能超出父元素，而父元素不会伸展开来以包含浮动元素。
浮动元素会延伸从而包含后代浮动元素。所以如果父元素 **(包括祖先元素)** 没有把浮动元素包含在内，那就将它设置为浮动元素，那么它就会展开以包含里面的浮动元素了。 P298

如果浮动元素比父元素宽，就会超出父元素，具体超出那边，取决于元素浮动的方向，左浮动则右边会超出，右浮动则左边会超出。

#### 浮动元素、内容和重叠 P302

浮动元素应该明确指定一个宽度，否则它会尽可能的窄。
如果一个浮动元素有负外边距，就可能与文档流中元素发生重叠。

- 行内框与一个浮动元素重叠时，其边框、背景、内容都在该浮动元素之上（内容更重要）
- 块框与一个浮动元素重叠时，其边框和背景在该浮动元素之下显示，内容还是在浮动元素之上显示。

#### 清除

`clear`

清除只能用于块级元素（或者生成块级框的元素）。 大多数浏览器为 `<br>` 生成汉内框，所以 clear 不能对 br 使用，除非改变它的 display 使其生成块级框。

css2.1 引入了清除区域，它在清除元素 **上边距之上** 增加额外的间隔，不允许任何浮动元素进入这个范围内。如果元素的外边距比清除区域小，那么就会被清除区域合并，所以看上去就像没有外边距，一般也无法知道一个元素周围多大范围内不允许有浮动元素，要确保具有 clear 的元素与浮动元素有一定的间距，可以为浮动元素设置一个下边距。

### 定位

`position`

定位会影响元素框的生成方式。

- static
  - 正常框，即块元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中
- relative
  - 元素框偏移某个距离，元素仍保持其未定位前的形状，它原本所占的空间仍保留。
- absolute
  - 元素框从文档流完全删除。不论原来它在正常流中生成何种类型的框，元素定位后生成一个块级框。它的定位是相对于包含块（文档中初始包含块或者是另一个元素）
- fixed
  - 元素框的表现类似于 absolute，不过它是相对于视窗本身。

#### 包含块

相对于浮动元素的包含块是最近的块级祖先元素，定位元素则相对复杂一些：

- “根元素” 的包含块（初始包含块）由用户代理创建。大多数浏览器将初始包含块定义为一个视窗大小的矩形。
- 非根元素
  - 如果position为relative或者static，则包含块是最近的块级框、表单元格或行内块祖先框的内容边界构成。
  - 如果position为absolute，包含块设置为最近的position不是static的祖先元素，过程如下：
    - 如果该祖先是块级元素，包含块则设置为该元素的内边距边界
    - 如果该祖先是行内元素，包含块则设置为该祖先元素的内容边界
    - 如果过没有祖先，元素的包含块可以定义为初始包含块。

#### 偏移属性

`top` `right` `bottom` `left`

初始值为 auto，它们应用于 position 为非 static 的元素。

百分数值时，top 和 bottom 相对于包含块的高度；right 和 left 相对于包含块的宽度。

#### 绝对定位

元素绝对定位时，会从文档流中删除，然后相对其包含块（最近的position非static的祖先元素）定位，定位元素不会流入其他文档流，这说明它们可能覆盖或被其他元素覆盖。最好的方法是选择一个元素作为绝对定位的包含块，给它添加 position 为 relative 即可。
