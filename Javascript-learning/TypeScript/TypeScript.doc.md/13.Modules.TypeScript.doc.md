# Modules

A note about terminology: It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with ECMAScript 2015’s terminology, (namely that module X { is equivalent to the now-preferred namespace X {).

术语注意事项: TypeScript 1.5 中, 为了符合ECMAScript 2015的术语，命名有所改变. "内部模块" 就是现在的 "命名空间".  "外部模块" 才是现在的 "模块 (即 `module X {` 就是现在的 `namespace X {`).

## 前言

Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.

自从 ECMAScript 2015 开始, JavaScript 就有了模块的概念. TypeScript 也沿用这个概念.

Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the `export` forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the `import` forms.

模块在其内部作用域中执行, 而非全局作用域. 也就是说在模块中声明的变量、函数、类等在模块外不可见, 除非显式的使用 `export` 导出它们. 相反, 如果要使用它们, 你必须通过 `import` 导入其他模块 `export` 导出来的内容.

Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.

模块是声明性的; 模块之间的关系通过文件的导入和导出来确定.

Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known modules loaders used in JavaScript are the CommonJS module loader for Node.js and require.js for Web applications.

模块之间是通过模块加载器相互引入的. 在运行时, 模块加载器负责在执行模块之前先定位和执行该模块的依赖. 比较知名的模块加载器有 Node.js 的 CommonJS 模块加载器和 Web 应用的 require.js

In TypeScript, just as in ECMAScript 2015, any file containing a top-level `import` or `export` is considered a module. Conversely, a file without any top-level `import` or `export` declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).

在 TypeScript 中, 和 ECMAScript 2015 中的一样,  任何包含顶级 `import` 或 `export` 的文件都被当做模块. 相反, 如果一个文件不包含顶级的 `import` 或 `export` 声明就会被当做一个全局作用域中的脚本 (也适用于模块).

## 导出

### 导出声明

Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the `export` keyword.

任何声明(如变量、函数、类、类型别名或者接口) 都能够通过关键字 `export` 导出.

```ts
// Validation.ts

export interface StringValidator {
    isAcceptable(s: string): boolean;
}
```

```ts
// ZipCodeValidator.ts

export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
```

### 导出语句

Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:

导出语句在为使用者导出需要命名的变量时非常方便, 因此前面的例子可以这样写:

```ts
class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
```

### 再次导出

Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.

通常会有一个模块继承自另一个模块, 并且只暴露其中的一部分特性. 再次导出不需要在本地导入, 或者引入本地变量.

```ts
// ParseIntBasedZipCodeValidator.ts

export class ParseIntBasedZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 && parseInt(s).toString() === s;
    }
}

// Export original validator but rename it
export {ZipCodeValidator as RegExpBasedZipCodeValidator} from "./ZipCodeValidator";
```

Optionally, a module can wrap one or more modules and combine all their exports using `export * from "module"` syntax.

一个模块可以封装一个或多个模块, 通过 `export * from "module"` 语法将它们合并导出.

```ts
// AllValidators.ts

export * from "./StringValidator"; // exports interface 'StringValidator'
export * from "./LettersOnlyValidator"; // exports class 'LettersOnlyValidator'
export * from "./ZipCodeValidator";  // exports class 'ZipCodeValidator'
```

### 导入

Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the `import` forms below:

导入和导出一样简单易用. 导入是使用关键字 `import` 来完成:

```ts
import { ZipCodeValidator } from "./ZipCodeValidator";

let myValidator = new ZipCodeValidator();
```

imports can also be renamed

导入的内容也可以重命名

```ts
import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";
let myValidator = new ZCV();
```

Import the entire module into a single variable, and use it to access the module exports

将以整个模块导入一个变量, 通过这个变量来访问模块导出的内容:

```ts
import * as validator from "./ZipCodeValidator";
let myValidator = new validator.ZipCodeValidator();
```

### 仅导入模块

Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:

虽然不推荐这么做, 但是有一些模块只是设置一些全局状态以供其它模块使用. 这些模块可能没有任何导出, 或者使用者并不关心它们导出了什么内容. 直接导入这些模块:

```ts
import "./my-module.js";
```

## 默认导出

Each module can optionally export a `default` export. Default exports are marked with the keyword `default`; and there can only be one `default` export per module. `default` exports are imported using a different import form.

每个模块都可以有一个 `default` 导出, 它被称之为默认导出. 默认导出使用关键字 `default`; 每个模块只能有一个默认导出. 默认导出使用的导入也有点不一样.

`default` exports are really handy. For instance, a library like JQuery might have a default export of `jQuery` or `$`, which we’d probably also import under the name `$` or `jQuery`.

默认导出非常方便. 比如, jQuery 可能默认导出了 `jQuery` 或 `$`, 因此我们也可以使用 `$` 或者 `jQuery` 来引入它们.

```ts
// JQuery.d.ts

declare let $: JQuery;
export default $;
```

```ts
// App.ts

import $ from "JQuery";

$("button.continue").html( "Next Step..." );
```

Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.

类和函数可以直接写作默认导出的格式. 默认导出的类和函数的名字是可选的.

```ts
// ZipCodeValidator.ts

export default class ZipCodeValidator {
    static numberRegexp = /^[0-9]+$/;
    isAcceptable(s: string) {
        return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);
    }
}
```

```ts
// Test.ts

import validator from "./ZipCodeValidator";

let myValidator = new validator();
```

or

或者

```ts
// StaticZipCodeValidator.ts

const numberRegexp = /^[0-9]+$/;

export default function (s: string) {
    return s.length === 5 && numberRegexp.test(s);
}
```

```ts
// Test.ts

import validate from "./StaticZipCodeValidator";

let strings = ["Hello", "98052", "101"];

// Use function validate
strings.forEach(s => {
  console.log(`"${s}" ${validate(s) ? " matches" : " does not match"}`);
});
```

`default` 导出也可以只导出值:

```ts
// OneTwoThree.ts

export default "123";
```

```ts
// Log.ts

import num from "./OneTwoThree";

console.log(num); // "123"
```

## `export =` 和 `import = require()`

Both CommonJS and AMD generally have the concept of an `exports` object which contains all exports from a module.

CommonJS 和 AMD 通常都有 `exports` 的概念, 这是一个包含了当前模块所有导出内容的对象(比如 Node.js 中 `exports = module.exports = ...` 这种).

They also support replacing the `exports` object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports `export =` to model the traditional CommonJS and AMD workflow.

它们也支持将 `exports` 对象替换为自定义的单个对象. 默认导出也就是这种替换, 然而它们之间并不兼容. TypeScript 支持使用 `export =` 来给传统的 CommonJS 和 AMD 工作流提供支持.

The `export =` syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.

`export =` 语法指定单个对象作为模块的导出. 它可以是类、接口、名字空间、函数或者枚举.

When exporting a module using `export =`, TypeScript-specific `import module = require("module")` must be used to import the module.

当使用 `export =` 来导出一个模块时, 必须使用 TypeScript 特定的 `import module = require("module")` 来导入模块.

```ts
// ZipCodeValidator.ts

let numberRegexp = /^[0-9]+$/;
class ZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
export = ZipCodeValidator;
```

```ts
// Test.ts

import zip = require("./ZipCodeValidator");

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validator = new zip();

// Show whether each string passed each validator
strings.forEach(s => {
  console.log(`"${ s }" - ${ validator.isAcceptable(s) ? "matches" : "does not match" }`);
});
```

## 模块的代码生成

Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (CommonJS), require.js (AMD), UMD, SystemJS, or ECMAScript 2015 native modules (ES6) module-loading systems. For more information on what the `define`, `require` and `register` calls in the generated code do, consult the documentation for each module loader.

在编译期间, 编译器会根据指定的模块编译目标为 `Node.js (CommonJS)`、 `require.js (AMD)`、 `UMD`、 `SystemJS` 或者 `ECMAScript 2015 native modules (ES6) module-loading systems` 生成对应的代码. 如果希望了解生成的代码中有关 `define` 、 `require` 和 `register` 调用的具体信息, 请查看相应模块加载器的文档.

This simple example shows how the names used during importing and exporting get translated into the module loading code.

这个简单的例子展示了在导入和导出过程中使用的名称是如何被翻译成模块加载代码的。

```ts
// SimpleModule.ts

import m = require("mod");
export let t = m.something + 1;
```

```js
// AMD / RequireJS SimpleModule.js

define(["require", "exports", "./mod"], function (require, exports, mod_1) {
    exports.t = mod_1.something + 1;
});
```

```js
// CommonJS / Node SimpleModule.js

var mod_1 = require("./mod");
exports.t = mod_1.something + 1;
```

```js
// UMD SimpleModule.js

(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./mod"], factory);
    }
})(function (require, exports) {
    var mod_1 = require("./mod");
    exports.t = mod_1.something + 1;
});
```

```js
// System SimpleModule.js

System.register(["./mod"], function(exports_1) {
    var mod_1;
    var t;
    return {
        setters:[
            function (mod_1_1) {
                mod_1 = mod_1_1;
            }],
        execute: function() {
            exports_1("t", t = mod_1.something + 1);
        }
    }
});
```

```js
// Native ECMAScript 2015 modules SimpleModule.js

import { something } from "./mod";
export var t = something + 1;
```

## 简单示例

Below, we’ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.

下面, 我们把前面的每个例子改成只导出单个具名的内容(导出内容).

To compile, we must specify a module target on the command line. For Node.js, use --module commonjs; for require.js, use --module amd. For example:

我们通过命令行给模块指定了编译目标. 如果要给 Node.js 指定, 使用 `--module commonjs`; 如果指定为 `require.js` 使用 `--module amd`:

`tsc --module commonjs Test.ts`

When compiled, each module will become a separate .js file. As with reference tags, the compiler will follow import statements to compile dependent files.

```ts
// Validation.ts

export interface StringValidator {
    isAcceptable(s: string): boolean;
}
```

```ts
// LettersOnlyValidator.ts

import { StringValidator } from "./Validation";

const lettersRegexp = /^[A-Za-z]+$/;

export class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}
```

```ts
// ZipCodeValidator.ts

import { StringValidator } from "./Validation";

const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
```

```ts
// Test.ts

import { StringValidator } from "./Validation";
import { ZipCodeValidator } from "./ZipCodeValidator";
import { LettersOnlyValidator } from "./LettersOnlyValidator";

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validators: { [s: string]: StringValidator; } = {};
validators["ZIP code"] = new ZipCodeValidator();
validators["Letters only"] = new LettersOnlyValidator();

// Show whether each string passed each validator
strings.forEach(s => {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
});
```

## 可选模块加载和其它高级加载方案

In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.

在某些情况下, 你可能希望在满足特定条件时才加载指定模块. 在 TypeScript 中, 我们可以使用下面展示的模式来实现这种加载方式和一些其他高级加载场景以直接调用模块加载器而不会丢失类型安全.

The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no `require` call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.

编译器检查每个模块是否在编译的 JavaScript 中有使用. 如果一个模块标识符(即导入的模块引用)只在类型注解中使用而没有在作为表达式使用, 那么该模块就不会有 `require` 调用. 省略掉没有使用到的引用对性能十分有益, 并且带来了按需加载模块的能力.

The core idea of the pattern is that the `import id = require("...")` statement gives us access to the types exposed by the module. The module loader is invoked (through `require`) dynamically, as shown in the `if` blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it’s important that the symbol defined via an `import` is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).

这种模式的核心思想就是使用 `import id = require("...")` 能够让我们访问模块暴露出来的类型. 像下面这样使用 `if` 语句块可以让模块加载器动态调用模块(通过`require`). 这种方式充分利用了引用优化, 模块只会在需要时被加载. 为了让这个模块能够工作, 最重要的是通过 `import` 得到的符号只能用在跟类型有关的地方(如 不能在会转换成JavaScript的地方)(type positions 翻译为类型相关的地方, 意思就是只会用于类型判断而不会执行模块中具体的代码)

      理解: 通过 require 引入的变量, 如果不在表达式中使用, 只是引入了模块到一个变量, 那么它就不会被模块加载器加载, 如果它在表达式中使用了, 那么它就会被模块加载器加载到代码中. 如果在某些条件下我们不需要加载这个模块, 而其他一些情况我们又可能会加载这个模块, 那么就可以像下面示例一样通过 if 对条件进行区分.

To maintain type safety, we can use the typeof keyword. The typeof keyword, when used in a type position, produces the type of a value, in this case the type of the module.

我们可以使用 `typeof` 关键字来确保类型安全. `typeof` 用在类型相关的地方会得到一个类型值, 这个值就是这个模块的类型.

```ts
// Dynamic Module Loading in Node.js

declare function require(moduleName: string): any;

import { ZipCodeValidator as Zip } from "./ZipCodeValidator";

if (needZipValidation) {
    let ZipCodeValidator: typeof Zip = require("./ZipCodeValidator");
    let validator = new ZipCodeValidator();
    if (validator.isAcceptable("...")) { /* ... */ }
}
```

```ts
// Sample: Dynamic Module Loading in require.js

declare function require(moduleNames: string[], onLoad: (...args: any[]) => void): void;

import * as Zip from "./ZipCodeValidator";

if (needZipValidation) {
    require(["./ZipCodeValidator"], (ZipCodeValidator: typeof Zip) => {
        let validator = new ZipCodeValidator.ZipCodeValidator();
        if (validator.isAcceptable("...")) { /* ... */ }
    });
}
```

```ts
// Sample: Dynamic Module Loading in System.js

declare const System: any;

import { ZipCodeValidator as Zip } from "./ZipCodeValidator";

if (needZipValidation) {
    System.import("./ZipCodeValidator").then((ZipCodeValidator: typeof Zip) => {
        var x = new ZipCodeValidator();
        if (x.isAcceptable("...")) { /* ... */ }
    });
}
```

## 和其它 JavaScript 库结合工作

To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.

当我们需要配合那些不是使用 TypeScript 来写的第三方库一起使用的时候，我们需要对第三方库暴露出来的API进行声明。

We call declarations that don’t define an implementation “ambient”. Typically, these are defined in `.d.ts` files. If you’re familiar with C/C++, you can think of these as `.h` files. Let’s look at a few examples.

我们把那些还没有定义具体实现的声明称为 “周边的”（“ambient”）。通常它们被定义在 `.d.ts` 文件中。如果你对 C/C++ 比较熟悉， 你可以把这些文件当做 `.h` 头文件， 下面会用例子进行演示。

### 周边模块 （Ambient Modules）

In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own `.d.ts` file with top-level export declarations, but it’s more convenient to write them as one larger `.d.ts` file. To do so, we use a construct similar to ambient namespaces, but we use the `module` keyword and the quoted name of the module which will be available to a later import. For example:

Node.js 中的大多数任务都是通过一个或多个模块完成的。我们可以在每个模块的 `.d.ts` 文件中使用顶级 export 声明来定义每个周边模块，但是更方便的是使用一个大的 `.d.ts` 文件来集体声明。为此，我们使用一个类似于周边的名字空间的形式，但是使用关键字 `module` 和引号引起来的供后面使用的模块名。例如：

```ts
// node.d.ts (simplified excerpt)

declare module "url" {
    export interface Url {
        protocol?: string;
        hostname?: string;
        pathname?: string;
    }

    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;
}

declare module "path" {
    export function normalize(p: string): string;
    export function join(...paths: any[]): string;
    export var sep: string;
}
```

Now we can `/// <reference> node.d.ts` and then load the modules using `import url = require("url");` or `import * as URL from "url"`.

现在我们可以使用 `/// <reference> node.d.ts` 并且使用 `import url = require("url");` 或者 `import * as URL from "url"` 来加载模块。

```ts
/// <reference path="node.d.ts"/>
import * as URL from "url";
let myUrl = URL.parse("http://www.typescriptlang.org");
```

### 周边模块简写 （Shorthand ambient modules）

If you don’t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.

如果你不想使用模块之前花时间来写它的声明文件，你可以使用声明简写来快速开始开发。

```ts
// declarations.d.ts

declare module "hot-new-module";
```

All imports from a shorthand module will have the `any` type.

所有从简写模块引入的内容类型都为 `any`。

```ts
import x, {y} from "hot-new-module";
x(y);
```

### 通配符模块声明 （Wildcard module declarations）

Some module loaders such as SystemJS and AMD allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.

一些像 SystemJS 和 AMD 的模块加载器允许允许引入非 JavaScript 内容。这些通常使用前缀或后缀来表示特殊的加载语义。通配符模块声明可用于涵盖这些情况。

```ts
declare module "*!text" {
    const content: string;
    export default content;
}
// Some do it the other way around.
declare module "json!*" {
    const value: any;
    export default value;
}
```

Now you can import things that match `"*!text"` or `"json!*"`.

现在你可以引入像 `"*!text"` 或者 `"json!*"` 这样的内容。

```ts
import fileContent from "./xyz.txt!text";
import data from "json!http://example.com/data.json";
console.log(data, fileContent);
```

### UMD 模块

Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as UMD modules. These libraries can be accessed through either an import or a global variable. For example:

一些第三方库被设计为可以在许多模块加载器中加载，或者没有模块加载（全局变量）。这些就被称作 UMD 模块。这些库通过 `import` 或者全局变量访问，例如：

```ts
// math-lib.d.ts

export function isPrime(x: number): boolean;
export as namespace mathLib;
```

The library can then be used as an import within modules:

这个库可以在模块中使用 `import` 引用：

```ts
import { isPrime } from "math-lib";
isPrime(2);
mathLib.isPrime(2); // ERROR: can't use the global definition from inside a module
```

It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)

也可以当做全局变量使用，但仅限于在脚本中（脚本就是没有 imports 和exports 的文件）：

```ts
mathLib.isPrime(2);
```

## Guidance for structuring modules
