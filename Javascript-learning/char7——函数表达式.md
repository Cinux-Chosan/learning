#char 7 —— 函数表达式

> FireFox，Safari，Chrome，Opera 给函数定义了一个非标准的name属性，即：

                            function f() {};
                            f.name == 'f';
> 以下代码为无效代码，浏览器可能会尝试修复该代码，但是不同的浏览器可能方式不一样，就会导致结果不一致：

                            if (condition) {
                              function sayHi() {
                                alert("Hi!")
                              }
                            } else {
                              function sayHi() {
                                alert('Yo!');
                              }
                            }

> 递归，为了解决函数名的引用被改变从而导致出现问题，在函数体内最好使用arguments.callee来指向当前函数，但是由于严格模式下无法通过脚本访问arguments.callee，可以使用命名函数表达式来达成相同效果：

                            var factorial = (function f(num) {
                              if (num <= 1) {
                                return 1;
                              } else {
                                return num * f(num-1);
                              }
                            });

> 闭包：闭包就是有权访问另一个函数作用域中变量的函数。创建闭包的常用方式，就是在一个函数内部创建另一个函数：

> 其实，**作用域链** 本质上是一个指向变量对象的 **指针列表**，它只引用但不包含变量对象。

> 在 **创建** 函数的时候，会创建一个预先包含全局变量对象的作用域链，保存在内部的[[Scope]]属性中；在 **调用** 函数的时候，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链，此后，又一个活动对象 —— 变量对象被创建并被推入执行环境作用域链的前端。此时作用域链中包含两个变量对象：本地活动对象 和 全局变量对象。
























































































。
