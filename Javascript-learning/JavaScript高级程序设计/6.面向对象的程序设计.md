# 面向对象的程序设计

## 6.1 理解对象

### 6.1.1 属性类型

ECMA-262第五版定义了只有内部才用的特性（attribute），它描述了属性（property） 的各种特性。定义这些特性的目的是为了 JavaScript 引擎使用，因此直接在 JavaScript 中无法访问它们。为了表示其为内部特性，规范将它们放到 `[[]]` 中，如 `[[Enumerable]]`。（注：我个人更习惯称其为 “属性描述符”，下同）

ECMAScript 中有两种属性：数据熟悉和访问器属性。

- 数据属性：
  - `[[Configurable]]`: 默认为 `true`，表示能否通过 `delete` 删除属性从而重新定义该属性，能否修改属性的描述符，或能否将属性修改为访问器属性。
  - `[[Enumerable]]`: 默认为 `true`，表示该属性是否会出现在 `for-in` 循环中。
  - `[[Writable]]`: 默认为 `true`，表示能否修改该属性的值。
  - `[[Value]]`: 默认为 `undefined`，属性的具体值。

- 访问器属性：
  - `[[Configurable]]`: 默认为 `true`
  - `[[Enumerable]]`: 默认为 `true`
  - `[[Get]]`: 默认为 `undefined`
  - `[[Set]]`: 默认为 `undefined`

如果要修改属性的描述符，必须使用 ECMAScript5 中的 Object.defineProperty() 方法。（此书当前是依照 ES5 的标准，不考虑 ES6 ）
访问器属性不能直接定义，必须使用 ECMAScript5 中的 Object.defineProperty() 方法。

```js
var o = { name: 'chosan' };
Object.defineProperty(o, 'name', {
  writable: false
})
```

如果对属性的操作与属性描述符相违背（如：修改 `writable:false` 属性的值，或对 `configurable:false` 的属性执行 `delete` 等），在非严格模式下将直接被忽略，在严格模式下将抛出异常。

支持 ECMAScript 5 这个方法的浏览器有 IE9+(IE8只是部分实现)， Firefox4+， Safari 5+，Opera 12+ 和 Chrome。在这个方法之前，要创建访问器属性，一般使用两个非标准方法：`__defineGetter__()` 和 `__defineSetter__()`：

```js
var book = {
  _year: 2004,
  edition: 1
};

book.__defineGetter__('year', function () {
  return this._year;
});

book.__defineSetter__('year', function (newVal) {
  if (newVal > 2004) {
    this._year = newVal;
    this.edition += newVal - 2004;
  }
});

book.year = 2005;
alert(book.edition); // 2

```

定义多个属性及其描述符使用 `Object.defineProperties()`

### 6.1.3 读取属性的特性

使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象：
- 如果是访问器属性，则这个对象属性有 configurable, enumerable, get, set
- 如果是数据属性，则这个对象属性有 configurable, enumerable, writable, value


## 6.2 创建对象 P144

由于 Object 构造函数或者对象字面量都可以用来创建单个对象会产生大量重复的代码，为了解决这个问题，人们开始使用工厂模式：

### 工厂模式

工厂模式抽象了创建具体对象的过程，考虑到 ECMAScript 中无法创建类（ES5 截止还没有 `class` 产生），开发人员就发明了一种用来封装创建特定对象细节的函数，如：

```js
function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}

var person1 = createPerson('Nicholas', 29, 'Software Engineer');
var person2 = createPerson('Greg', 27, 'Doctor');
```

工厂模式虽然解决了创建多个相似对象的问题，却没有解决对象的识别问题 —— 怎样知道一个对象的类型。因此又出现了一个新的模式。

### 构造函数模式

使用构造函数模式重写工厂模式中的例子：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function(){
    alert(this.name);
  }
}
var person1 = Person('Nicholas', 29, 'Software Engineer');
var person2 = Person('Greg', 27, 'Doctor');
```

与工厂模式区别在于：

- 没有显示创建对象
- 直接将属性和方法赋值给了 `this`
- 没有 `return` 语句
- 使用 `new` 操作符创建实例

创建实例时，必须使用 `new` 操作符，它会经历以下四步：
- 创建一个新对象
- 将构造函数的作用域赋给新对象（因此 `this` 就指向这个新对象）
- 执行构造函数中的代码
- 返回新对象

在构造函数模式中创建的两个实例都有一个 `constructor` 属性，该属性指向 Person，因此 
```js
person1.constructor === Person; // true
person2.constructor === Person; // true
```

对象的 `constructor` 属性最初是用来标识对象类型的，不过检测对象类型还是使用 `instanceof` 操作符更可靠。

```js
person1 instanceof Object; // true
person1 instanceof Person; // true
// person2 也是如此
```

构造函数模式可以将它们创建的对象标识为自定义的类型，因此它胜过了工厂模式。但是它也有自己的问题，那就是每个函数都有一个自己的 sayName 方法（因为 JavaScript 中函数也是对象），这完全是没有必要的，可以如下优化：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

// 将 sayName 提炼出来，而不是每个对象都有一个自己的 sayName
function sayName(){
    alert(this.name);
}
var person1 = Person('Nicholas', 29, 'Software Engineer');
var person2 = Person('Greg', 27, 'Doctor');
```

这样优化带来的问题也显而易见，也就是会创建太多像 sayName 一样的全局函数，因此，又出现了一种模式 —— 原型模式。

### 6.2.3 原型模式

#### 1. 理解原型对象

无论什么时候，只要创建了一个新函数，就会根据一组特定规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个 constructor 属性，这个属性为一个指向当前 prototype 属性的函数指针，即 Person.prototype.constructor 指向 Person。

每创建一个函数，就会同时创建它的原型对象 prototype，该原型对象默认（只）会得到一个 constructor 属性，其他方法都是从 Object 继承而来。

```js
function A () {}
// 因为 A 是 Function 的一个实例对象，因此 A.constructor === Function.prototype.constructor === Function.constuctor 即在 Chrome 中输出 ƒ Function() { [native code] }
A.constructor;  // ƒ Function() { [native code] }   
A.prototype.constructor;  // ƒ A () {}
```

使用构造函数创建实例过后，实例内部包含一个指向构造函数的原型的内部指针 —— `[[Prototype]]`。虽然在脚本中没有标准方式访问 `[[Prototype]]`，但是 Firefox、Safari 和 Chrome 在每个对象上都支持一个 `__proto__` 属性，而在其它实现中，这个属性对脚本则是完全不可见的，如：

```js
function  A (){}
var a = new A;
a.__proto__;  // 在实现了的浏览器上输出原型对象，如 {constructor: ƒ} ， 在未实现的浏览器上（如 IE 11 之前）则为 undefined
```

因此，你可能会在 TypeScript 编译文件中发现对 `__proto__` 属性的检测：

```ts
declare class B {}

class A extends B {
}
```

编译后：

```js
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var A = /** @class */ (function (_super) {
    __extends(A, _super);
    function A() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return A;
}(B));
```

其中 `({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; })` 这段代码即是检测 `__proto__` 属性是否在当前浏览器环境中有实现：

```js
({ __proto__: [] }) instanceof Array;  // 在实现了 __proto__ 的浏览器上为 true，在未实现的浏览器上（如 IE11 之前）即为 false
```
如果有实现则执行 `d.__proto__ = b` 完成继承的部分阶段。

**需要注意的是：关于原型链的连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。**


虽然在所有实现中都无法访问到 `[[Prototype]]`，但是可以通过 `isPrototypeOf()` 方法来确定对象之间是否存在这种关系：

```js
Person.prototype.isPrototypeOf(person1); // true
Person.prototype.isPrototypeOf(person2); // true
```

ECMAScript 5 新增了一个方法 —— `Object.getPrototypeOf()`，该方法返回 `[[Prototype]]` 的值：

```js
// 该方法支持的浏览器为：IE9+，Firefox 3.5+，Safari 5+，Opera 12+ 和 Chrome
Object.getPrototypeOf(person1) === Person.prototype; // true
```

**另外一个需要注意的地方就是，访问属性会遍历原型，但是设置属性就与原型无关了，因为设置属性时会直接将属性设置在对象实例上而不会遍历原型去寻找同名的对象，因此给对象实例设置属性时会屏蔽原型中的同名属性，此时再次读取值时，由于当前实例上已经存在该属性，因此也不会遍历原型，这就是所谓的屏蔽。但是当在实例上调用 delete 删除掉该属性后，原型链上的同名属性又暴露出来了。**

**ECMAScript 5 的 `Object.getOwnPropertyDescriptor()` 只能用于实力属性，如果要取得原型属性的描述符，则必须直接在原型对象上调用 `Object.getOwnPropertyDescriptor()` 方法**

#### 2. 原型与 `in` 操作符

有两种方式使用 in 操作符：
- 单独使用 `in` 操作符：只要通过该实例能够访问到属性时（无论是实例属性还是原型属性），`in` 就返回 `true`，因此更多的场合可能需要结合 `hasOwnProperty()` 方法来判断当前属性是实例属性还是原型属性。
- 在 `for-in` 中使用：返回所有可以通过对象访问的（无论是实例属性还是原型属性）、可枚举的属性。屏蔽了原型中不可枚举属性的实力属性也会在 `for-in` 中返回，因为根据规定，所有开发人员定义的属性都是可枚举的 —— IE8 及更早版本中例外（P153）。


可以代替 `for-in` 的方法：
- `Object.keys()`：该方法返回所有可枚举的实例属性（非原型属性）
- `Object.getOwnPropertyNames()`：该方法返回所有实例属性（非原型属性、与是否可枚举无关）

支持 `Object.keys()` 和 `Object.getOwnPropertyNames()` 的浏览器有 IE 9+，Firefox 4+， Safari 5+，Opera 12+ 和 Chrome

#### 3. 更简单的原型语法

```js
function Person(){}

Person.prototype = {
  name: 'Nicholas',
  age: 29,
  job: 'Software Engineer',
  sayName: function() {
    alert(this.name);
  }
};
```

这样直接改写 prototype 属性，此时尽管 instanceof 操作符还能返回正确结果，但是此时 constructor 已经变成了新的对象的 constructor，此时通过 constructor 已经无法确定对象的类型了，如果 constructor 真的很重要，则需要对它进行设置：


```js
function Person(){}

Person.prototype = {
  constructor: Person, // +
  name: 'Nicholas',
  age: 29,
  job: 'Software Engineer',
  sayName: function() {
    alert(this.name);
  }
};
```

这样虽然设置了正确的 constructor 值，但是它的描述符属性 `[[Enumerable]]` 变为了 true，如果想要兼容这一点，可以使用 `Object.defineProperty()` 方法：

```js
// ...
Object.defineProperty(Person.prototype, 'constructor', {
  enumerable: false,
  value: Person
});
// ...
```

由于原型模式是直接将初始值赋值到原型链 prototype 对象上，会导致对一些引用类型的初始值的修改在各个实例之间进行共享，并且实例一般都需要有自己的全部属性（排除函数），因此很少有人单独使用原型模式。此时我们可以将原型模式与前面的模式进行结合使用 —— 组合使用构造函数模式和原型模式。

#### 6.2.4 组合使用构造函数模式和原型模式

```js
function Person (name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.friends = ['Shelby', 'Court'];
}

Person.prototype = {
  constructor: Person,
  sayName: function () {
    alert(this.name);
  }
}
```

这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。

#### 6.2.5 动态原型模式

其他 OO 语言的开发人员看到前面那种构造函数和原型分离的情况会非常困惑，因此动态原型模式就是为了解决这个问题：

```js
function Person (name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  if (typeof this.sayName != 'function') {
    Person.prototype.sayName = function () {
      alert(this.name);
    }
  }
}
```

该模式只是将组合构造函数模式和原型模式写在了一起，看起来混为一体。

#### 6.2.6 寄生构造函数模式

#### 6.2.7 稳妥构造函数模式