# 面向对象的程序设计

## 6.1 理解对象

### 6.1.1 属性类型

ECMA-262第五版定义了只有内部才用的特性（attribute），它描述了属性（property） 的各种特性。定义这些特性的目的是为了 JavaScript 引擎使用，因此直接在 JavaScript 中无法访问它们。为了表示其为内部特性，规范将它们放到 `[[]]` 中，如 `[[Enumerable]]`。（注：我个人更习惯称其为 “属性描述符”，下同）

ECMAScript 中有两种属性：数据熟悉和访问器属性。

- 数据属性：
  - `[[Configurable]]`: 默认为 `true`，表示能否通过 `delete` 删除属性从而重新定义该属性，能否修改属性的描述符，或能否将属性修改为访问器属性。
  - `[[Enumerable]]`: 默认为 `true`，表示该属性是否会出现在 `for-in` 循环中。
  - `[[Writable]]`: 默认为 `true`，表示能否修改该属性的值。
  - `[[Value]]`: 默认为 `undefined`，属性的具体值。

- 访问器属性：
  - `[[Configurable]]`: 默认为 `true`
  - `[[Enumerable]]`: 默认为 `true`
  - `[[Get]]`: 默认为 `undefined`
  - `[[Set]]`: 默认为 `undefined`

如果要修改属性的描述符，必须使用 ECMAScript5 中的 Object.defineProperty() 方法。（此书当前是依照 ES5 的标准，不考虑 ES6 ）
访问器属性不能直接定义，必须使用 ECMAScript5 中的 Object.defineProperty() 方法。

```js
var o = { name: 'chosan' };
Object.defineProperty(o, 'name', {
  writable: false
})
```

如果对属性的操作与属性描述符相违背（如：修改 `writable:false` 属性的值，或对 `configurable:false` 的属性执行 `delete` 等），在非严格模式下将直接被忽略，在严格模式下将抛出异常。

支持 ECMAScript 5 这个方法的浏览器有 IE9+(IE8只是部分实现)， Firefox4+， Safari 5+，Opera 12+ 和 Chrome。在这个方法之前，要创建访问器属性，一般使用两个非标准方法：`__defineGetter__()` 和 `__defineSetter__()`：

```js
var book = {
  _year: 2004,
  edition: 1
};

book.__defineGetter__('year', function () {
  return this._year;
});

book.__defineSetter__('year', function (newVal) {
  if (newVal > 2004) {
    this._year = newVal;
    this.edition += newVal - 2004;
  }
});

book.year = 2005;
alert(book.edition); // 2

```

定义多个属性及其描述符使用 `Object.defineProperties()`

### 6.1.3 读取属性的特性

使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象：
- 如果是访问器属性，则这个对象属性有 configurable, enumerable, get, set
- 如果是数据属性，则这个对象属性有 configurable, enumerable, writable, value


## 6.2 创建对象 P144

由于 Object 构造函数或者对象字面量都可以用来创建单个对象会产生大量重复的代码，为了解决这个问题，人们开始使用工厂模式：

### 工厂模式

工厂模式抽象了创建具体对象的过程，考虑到 ECMAScript 中无法创建类（ES5 截止还没有 `class` 产生），开发人员就发明了一种用来封装创建特定对象细节的函数，如：

```js
function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}

var person1 = createPerson('Nicholas', 29, 'Software Engineer');
var person2 = createPerson('Greg', 27, 'Doctor');
```

工厂模式虽然解决了创建多个相似对象的问题，却没有解决对象的识别问题 —— 怎样知道一个对象的类型。因此又出现了一个新的模式。

### 构造函数模式

使用构造函数模式重写工厂模式中的例子：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function(){
    alert(this.name);
  }
}
var person1 = Person('Nicholas', 29, 'Software Engineer');
var person2 = Person('Greg', 27, 'Doctor');
```

与工厂模式区别在于：

- 没有显示创建对象
- 直接将属性和方法赋值给了 `this`
- 没有 `return` 语句
- 使用 `new` 操作符创建实例

创建实例时，必须使用 `new` 操作符，它会经历以下四步：
- 创建一个新对象
- 将构造函数的作用域赋给新对象（因此 `this` 就指向这个新对象）
- 执行构造函数中的代码
- 返回新对象

在构造函数模式中创建的两个实例都有一个 `constructor` 属性，该属性指向 Person，因此 
```js
person1.constructor === Person; // true
person2.constructor === Person; // true
```

对象的 `constructor` 属性最初是用来标识对象类型的，不过检测对象类型还是使用 `instanceof` 操作符更可靠。

```js
person1 instanceof Object; // true
person1 instanceof Person; // true
// person2 也是如此
```

构造函数模式可以将它们创建的对象标识为自定义的类型，因此它胜过了工厂模式。但是它也有自己的问题，那就是每个函数都有一个自己的 sayName 方法（因为 JavaScript 中函数也是对象），这完全是没有必要的，可以如下优化：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

// 将 sayName 提炼出来，而不是每个对象都有一个自己的 sayName
function sayName(){
    alert(this.name);
}
var person1 = Person('Nicholas', 29, 'Software Engineer');
var person2 = Person('Greg', 27, 'Doctor');
```

这样优化带来的问题也显而易见，也就是会创建太多像 sayName 一样的全局函数，因此，又出现了一种模式 —— 原型模式。