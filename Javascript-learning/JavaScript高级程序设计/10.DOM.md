# DOM

文档元素是文档最外层的元素，如在 HTML 中为 `<html>` 元素。

总共有12中节点类型

## 10.1.1 Node类型

DOM1 定义了一个 Node 接口（IE 中不可访问），该接口将由 DOM 中的所有节点类型实现。JavaScript中所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。

每个节点都有一个 nodeType 属性，它用于表明节点的类型。节点类型由在 Node 类型中定义的下列 12 个数值常量来表示，任何节点类型必居其一：
- Node.ELEMENT_NODE(1)
- Node.ATTRIBUTE_NODE(2)
- Node.TEXT_NODE(3)
- Node.CDATA_SECTION_NODE(4)
- Node.ENTITY_REFERENCE_NODE(5)
- Node.ENTITY_NODE(6)
- Node.PROCESSING_INSTRUCTION_NODE(7)
- Node.COMMENT_NODE(8)
- Node.DOCUMENT_NODE(9)
- Node.DOCUMENT_TYPE_NODE(10)
- Node.DOCUMENT_FRAGMENT_NODE(11)
- Node.NOTATION_NODE(12)

由于 IE 中不可访问 Node 对象，因此下面的代码应该使用数值型：

```js
if (someNode.nodeType == Node.ELEMENT_NODE) { // IE 中无效，因为无法访问 Node
  // TODO
}
```

换成：

```js
if (someNode.nodeType == 1) { // 使用节点的数字值，兼容所有浏览器
  // TODO
}
```

#### nodeName 和 nodeValue

nodeName 获取节点名，nodeValue 获取节点值。

```js
if (someNode.nodeType == 1) {  // 使用之前先检测节点类型，看它是不是一个元素
  value = someNode.nodeName;
}
```

对于元素节点，nodeName 中保存的始终是元素的标签名，而 nodeValue 的值**始终为 null（即便是一个 input 元素）**。

#### 节点关系

每个节点都有一个 childNodes 属性，它是一个 NodeList 对象。需要注意的是：
- NodeList 虽然可以通过 `[]` 访问，并且也有 length 属性，但它并不是 Array 的实例
- NodeList 是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。我们常说，NodeList 是有生命、有呼吸的对象，而不是我们第一次访问它的某个瞬间拍摄下来的一个快照。

```js
var firstChild = someNode.childNodes[0];
var secondChild = someNode.childNodes.item(1);
var count = someNode.childNodes.length;
```

**每个节点**都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。此外，包含在 childNodes 列表中的每个节点之间互相都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性值同样也为 null：

```js
if (someNode.nextSibling === null) {
  alert('this is the last node');
} else if (someNode.previousSibling === null) {
  alert('this is the first node');
}
```

同时，父节点的 firstChild 和 lastChild 分别始终指向其 childNodes 列表中的第一个和最后一个节点。明确这些关系能够对我们查找和访问文档结构中的节点提供极大的便利。

另外，`hasChildNodes()` 也是一个非常有用的方法，这个方法在节点包含一个或多个子节点的情况下返回 true；应该说，这是比查询 childNodes 列表的 length 属性更简单的方法。

**所有节点都有的**最后一个属性是 `ownerDocument`，该属性指向表示整个文档的文档节点。通过这个属性，我们可以不必在节点层次中层层回溯到达顶端，而是可以直接访问文档节点。

#### 操作节点

- appendChild() 用于向 childNodes 列表的末尾添加一个节点，返回新增的节点。添加节点后，childNodes 新增节点、父节点及以前的最后一个子节点的关系指针都会相应的更新。如果传入的节点已经是文档的一部分，则结果就是将该节点从原来的位置转移到新位置。因此可以使用 appendChild() 直接将元素 childNodes 中第一个元素移动到最后一个元素去。

```js
//  someNode 有多个子节点
var returnedNode = someNode.appendChild(someNode.firstChild);
returnedNode == someNode.firstChild; // false
returnedNode == someNode.lastChild;  // true
```

- insertBefore() 将节点放在 childNodes 中的特定位置上，返回插入元素。参数为要插入的节点和作为参照的节点。如果参照节点是 `null`，则 insertBefore() 和 appendChild() 执行相同的操作。

```js
returnedNode = someNode.insertBefore(newNode, null);
newNode == someNode.lastChild;  // true
```

- replaceChild() 使用插入节点替换指定节点，返回替换的节点并从文档树中被移除。参数为插入的节点和要替换的节点。

```js
// 替换第一个节点
var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);
```

- removeChild() 移除并返回节点。

#### 其他方法

有两个方法是所有类型的节点都有的。

- cloneNode() 创建调用该方法节点的一个完全相同的副本。它接受一个布尔值作为参数，表示是否执行深复制。在参数为 true 时执行深复制。
  - true：执行深复制。它会复制节点及其整个子节点树。
  - false：执行浅复制。

复制的节点属于文档所有，但是并没有为它指定父节点，因此这个副本节点就成了一个孤儿。需要通过 appendChild()、insertBefore() 或者 replaceChild() 将它添加到文档中。


```html
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  <li>item 4</li>
</ul>
```

```js
var list = document.getElementById('list');

var deepList = list.cloneNode(true);
deepList.childNodes.length;  // 3（IE < 9）或 7 （其他浏览器），这里的差异主要是因为 IE 8 机器更早版本与其他浏览器处理空白字符的方式不一样

var shallowList = list.cloneNode(false);
shallowList.childNodes.length;  // 0
```

- normalize() 方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或 DOM 操作的原因，可能会出现文本节点不包含文本，或者连接出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点就删除它，找到相邻文本节点则合并为一个。

### 10.1.2 Document 类型

JavaScript中通过 Document 类型表示文档，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。且 document 是 window 对象的一个属性，因此可以全局访问。Document 节点具有以下特征：
- nodeType 为 9
- nodeName 为 “#document”
- nodeValue 为 null
- parentNode 为 null
- ownerDocument 为 null
- 子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。

Document 类型表示 HTML 页面或者其他基于 XML 的文档，最常见的也就是作为 HTMLDocument 实例的 document 对象。

#### 1. 文档的子节点

虽然 DOM 标准规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingInstruction 或 Comment，但是还有两个内置的访问其子节点的快捷方式：
- documentElement：该属性始终指向 HTML 页面中的 `<html>` 元素。
- childNodes：子节点，可以用于访问文档元素，但 documentElement 更便捷。

document 对象还有一个 body 属性，直接指向 `<body>` 元素。

**所有浏览器都支持 document.documentElement 和 document.body 属性。**

document 的另一个可能的子节点是 DocumentType。通常将 `<!DOCTYPE>` 标签看成与文档其他部分不同的实体，可以通过 doctype 属性访问（具体实现差异请查看 《JavaScript高级程序设计》第三版 P254）：

```js
var doctype = document.doctype;  // 获取对 <!DOCTYPE> 的引用
```

通常情况下，我们都用不着在 document 对象上调用 appendChild()、removeChild() 和 replaceChild()，因为文档类型（如果存在的话）是只读的，且它只能有一个元素子节点。

#### 2. 文档信息

作为 HTMLDocument 的一个实例，document 对象还有一些标准的 Document 对象所没有的属性：
- title：可以获取和设置网页标题，但改变它并不会影响 `<title>` 元素
- URL：包含页面的完整 URL
- referrer：链接到当前页面的 URL。在没有来源的情况下，该属性可能为空字符串。
- domain：页面的域名

只有 title 和 domain 是可以设置的，并且出于安全方面的原因 domain 并非可以设置任意值，只能将 domain 设置为更上级域名，如本来是 p2p.wrox.com，那么只能将其设置为 wrox.com。

当页面中包含其他子域的框架或内嵌框架时，能够设置 document.domain 就非常方便了。由于跨域安全限制，来自不同子域的页面无法通过 JavaScript 通信。而通过将每个页面的 document.domain 设置为相同的值，这些页面就可以相互访问对方包含的 JavaScript 对象了。例如，假设有一个页面加载自 www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自 p2p.wrox.com。由于 document.domain 字符串不一样，内外两个页面之间无法相互访问对方的 JavaScript 对象。但如果将这两个页面的 document.domain 都设置为 wrox.com，则它们之间就可以相互通信了。

浏览器对 domain 属性还有一个限制，即如果域名一开始是“松散的（loose）”，那么就不能将其再设置为“紧绷的（tight）”。换句话说，在将 document.domain 设置为 wrox.com 之后，就不能再将其设置回 p2p.wrox.com 了，否则将会报错。

#### 3. 查找元素