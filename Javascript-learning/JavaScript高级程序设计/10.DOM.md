# DOM

文档元素是文档最外层的元素，如在 HTML 中为 `<html>` 元素。

总共有12中节点类型

## 10.1.1 Node类型

DOM1 定义了一个 Node 接口（IE 中不可访问），该接口将由 DOM 中的所有节点类型实现。JavaScript中所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法。

每个节点都有一个 nodeType 属性，它用于表明节点的类型。节点类型由在 Node 类型中定义的下列 12 个数值常量来表示，任何节点类型必居其一：
- Node.ELEMENT_NODE(1)
- Node.ATTRIBUTE_NODE(2)
- Node.TEXT_NODE(3)
- Node.CDATA_SECTION_NODE(4)
- Node.ENTITY_REFERENCE_NODE(5)
- Node.ENTITY_NODE(6)
- Node.PROCESSING_INSTRUCTION_NODE(7)
- Node.COMMENT_NODE(8)
- Node.DOCUMENT_NODE(9)
- Node.DOCUMENT_TYPE_NODE(10)
- Node.DOCUMENT_FRAGMENT_NODE(11)
- Node.NOTATION_NODE(12)

由于 IE 中不可访问 Node 对象，因此下面的代码应该使用数值型：

```js
if (someNode.nodeType == Node.ELEMENT_NODE) { // IE 中无效，因为无法访问 Node
  // TODO
}
```

换成：

```js
if (someNode.nodeType == 1) { // 使用节点的数字值，兼容所有浏览器
  // TODO
}
```

#### nodeName 和 nodeValue

nodeName 获取节点名，nodeValue 获取节点值。

```js
if (someNode.nodeType == 1) {  // 使用之前先检测节点类型，看它是不是一个元素
  value = someNode.nodeName;
}
```

对于元素节点，nodeName 中保存的始终是元素的标签名，而 nodeValue 的值**始终为 null（即便是一个 input 元素）**。

#### 节点关系

每个节点都有一个 childNodes 属性，它是一个 NodeList 对象。需要注意的是：
- NodeList 虽然可以通过 `[]` 访问，并且也有 length 属性，但它并不是 Array 的实例
- NodeList 是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。我们常说，NodeList 是有生命、有呼吸的对象，而不是我们第一次访问它的某个瞬间拍摄下来的一个快照。

```js
var firstChild = someNode.childNodes[0];
var secondChild = someNode.childNodes.item(1);
var count = someNode.childNodes.length;
```

**每个节点**都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。此外，包含在 childNodes 列表中的每个节点之间互相都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性值同样也为 null：

```js
if (someNode.nextSibling === null) {
  alert('this is the last node');
} else if (someNode.previousSibling === null) {
  alert('this is the first node');
}
```

同时，父节点的 firstChild 和 lastChild 分别始终指向其 childNodes 列表中的第一个和最后一个节点。明确这些关系能够对我们查找和访问文档结构中的节点提供极大的便利。

另外，`hasChildNodes()` 也是一个非常有用的方法，这个方法在节点包含一个或多个子节点的情况下返回 true；应该说，这是比查询 childNodes 列表的 length 属性更简单的方法。

**所有节点都有的**最后一个属性是 `ownerDocument`，该属性指向表示整个文档的文档节点。通过这个属性，我们可以不必在节点层次中层层回溯到达顶端，而是可以直接访问文档节点。

#### 操作节点

- appendChild() 用于向 childNodes 列表的末尾添加一个节点，返回新增的节点。添加节点后，childNodes 新增节点、父节点及以前的最后一个子节点的关系指针都会相应的更新。如果传入的节点已经是文档的一部分，则结果就是将该节点从原来的位置转移到新位置。因此可以使用 appendChild() 直接将元素 childNodes 中第一个元素移动到最后一个元素去。

```js
//  someNode 有多个子节点
var returnedNode = someNode.appendChild(someNode.firstChild);
returnedNode == someNode.firstChild; // false
returnedNode == someNode.lastChild;  // true
```

- insertBefore() 将节点放在 childNodes 中的特定位置上，返回插入元素。参数为要插入的节点和作为参照的节点。如果参照节点是 `null`，则 insertBefore() 和 appendChild() 执行相同的操作。

```js
returnedNode = someNode.insertBefore(newNode, null);
newNode == someNode.lastChild;  // true
```

- replaceChild() 使用插入节点替换指定节点，返回替换的节点并从文档树中被移除。参数为插入的节点和要替换的节点。

```js
// 替换第一个节点
var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);
```

- removeChild() 移除并返回节点。

#### 其他方法

有两个方法是所有类型的节点都有的。

- cloneNode() 创建调用该方法节点的一个完全相同的副本。它接受一个布尔值作为参数，表示是否执行深复制。在参数为 true 时执行深复制。
  - true：执行深复制。它会复制节点及其整个子节点树。
  - false：执行浅复制。

复制的节点属于文档所有，但是并没有为它指定父节点，因此这个副本节点就成了一个孤儿。需要通过 appendChild()、insertBefore() 或者 replaceChild() 将它添加到文档中。


```html
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  <li>item 4</li>
</ul>
```

```js
var list = document.getElementById('list');

var deepList = list.cloneNode(true);
deepList.childNodes.length;  // 3（IE < 9）或 7 （其他浏览器），这里的差异主要是因为 IE 8 机器更早版本与其他浏览器处理空白字符的方式不一样

var shallowList = list.cloneNode(false);
shallowList.childNodes.length;  // 0
```

- normalize() 方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或 DOM 操作的原因，可能会出现文本节点不包含文本，或者连接出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点就删除它，找到相邻文本节点则合并为一个。