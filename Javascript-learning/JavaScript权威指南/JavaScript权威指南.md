

# 第四章：表达式与运算符
- 不同运算符之间，考虑优先级
- 多个相同优先级的运算符之间，考虑结合性（从左至右还是从右到左）
```js
var a = 1;
  a+ ++a; // 3
但是
  ++a+a; // 4


```
引用《JavaScript权威指南》 P69 的一段话：

`运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式的计算过程中的运算属性，JavaScript总是严格的按照从左至右的顺序来计算表达式，例如：w = x + y * z 中，首先计算子表达式 w，然后是 x、y、z，然后 y * z，再加上 x，最后将其赋值给 w 所指代的变量或属性。给表达式添加圆括号将会改变乘法、加法和赋值运算的关系，但从左至右的顺序是不会改变的。`

上面的例子中， a+ ++a 看成 a + y ； ++a+a 看成 y + a；所以第一个表达式计算顺序为 a, ++a, a+ ++a，第二个为 ++a, a, ++a+a。第一个计算 ++a的时候a的值已经定了，但是第二个计算完++a的时候再去计算a，此时a已经为2，所以结果为4

++a 是先将 a + 1，然后返回增加过后的值，而 a++ 是先加 1，但是返回的是加之前的值。所以 ++a+a 是先执行 ++a，并使用 ++a 执行完成过后的值再与 a 相加，而 a+ ++a 是先计算 a，此时第一个 a 已经被替换为a的值1，然后再执行 ++a，并返回 ++a 执行之后的值，所以就是 1 + 2 得 3

1、  `++[[]][+[]]+[+[]]=?`
2、 `([][+[]]+[])[+!![]]=?`

- null 是关键字，被强制转换成整型的值是 0，即 +null 是 0
- undefined 是全局变量，不是关键字，被强制转换成整型的值是 NaN， 即 +undefined 是 NaN

- `+` 运算符首先考虑字符串拼接，其次考虑算术运算的加，即 `1 + '1'` 和 `'1' + 1` 结果都是 `'11'`。 （P70）
- 比较运算符`> <` 则首先考虑转换成数字，然后比较。（与 `+` 不同） （P77）
- `++` 运算符从不进行字符串连接操作，它总是会将操作数转换为数字并增 1 （P72）

位运算要求它的操作数是整数，这些整数表示为 32位整型而不是 64位浮点型。必要时，位运算符会首先将操作数转换为数字，并将数字强制转换为 32 位整型，这会忽略原格式中的小数部分和任何超过32位的二进制位，移位运算符要求右操作数介于 [0, 31] 之间。在将其操作数转换为无符号 32 位整数后，它们将舍弃第 5 位之后的二进制位，以便生成一个正确的数字。位运算符会把 NaN、Infinity 和 - Infinity 都转换为 0；

- `&` 按位与
- `|` 按位或
- `^` 按位异或
- `~` 按位非，相当于改变符号后减 1
- `<<` 左移，右边新出现的位用 0 补充，相当于乘以 2
- `>>` 右移，左边多出来的位用符号位补充，整数为 0，负数为 1，相当于除以 2
- `>>>` 无符号右移，左边高位总是补 0，结果转换为无符号数，即正数


## 关于 eval （P83）

一般来说，如果一个函数调用了 eval()，那么解释器将无法对这个函数做进一步优化。eval返回最后一个表达式或者语句返回的值，无则相当于返回undefined，因为函数如果没有返回值也是返回undefined。

局部eval：直接调用 eval 时，它总是在调用它的上下文作用域内执行，它能够访问和修改到当前作用域内的变量

全局eval：通过别名等间接方式调用 eval 时，它的作用域为全局对象作用域，并且无法读、写、定义局部变量和函数（因为它无法访问到局部作用域，它所访问的全是全局作用域）

真正使用 eval 的场景并不多，但是如果当你意识到它的必要性时，你更可能会使用全局 eval 而非局部 eval（IE9之前早期IE和其他浏览器有所不同，见 P86）

严格eval：ES5 严格模式对eval进行了严格限制。当在严格模式调用 eval() 或者 eval()  执行的代码以 "use strict" 指令开始，则此时 eval 是私有上下文环境中的局部 eval，即：在严格模式下，eval执行代码可以查询或者更改局部变量， **但是不能在局部作用域定义新变量或函数** 。

## 关于 delete （P88）

delete希望它的操作数是一个左值，如果不是，则直接返回 true 而不进行任何操作。否则它会试图删除这个左值，如果删除成功就返回 true，否则返回 false，删除不存在的属性也是返回 true。

并非所有属性都可以删除，一些内置核心和客户端属性不能删除，通过var声明的变量也不能删除，通过 function 定义的函数和函数参数也不能删除。

严格模式：ES5严格模式中，如果delete操作数非法，比如变量、函数或函数参数，delete将抛出一个语法错误，只有操作数是一个属性访问表达式时才能正常工作。严格模式中，delete删除不可配置的属性也会判处一个类型错误异常，而非严格模式只会返回 true 或者 false。

```js
this.x = 1;
delete x;  // 非严格模式返回true，严格模式会抛出异常，严格模式使用 delete this.x 来替代
```

## 关于 void （P89）

void 可以像 typeof 一样写成 `void(表达式)` 也可以直接写成 `void 表达式`

表达式会正常计算，但是 void 始终返回 `undefined`

一个用法就是经常在 a 标签里面的 url 中使用：

```html
<a href="javascript:void window.open();">打开一个新窗口</a>
```

# **严格模式与非严格模式区别汇总**

P115



# 第六章: 对象

- Object.create(): 第一个参数为所要继承的原型, 第二个可选参数为新创建对象上属性的描述符. 第一个参数可以是 null, 此时创建的对象不继承任何东西, 甚至没有 toString 方法, 也就是说它和 `+` 进行运算也会报错.

- 在 JavaScript 中, 只有查询属性的时候才会体现出继承的存在, 设置属性值的时候与继承无关, 查询属性的时候, 如果该属性不为该对象的自有属性, 则会查找原型链, 但是设置属性的时候, 该属性会被设置为对象的自有属性, 会覆盖但不影响原型属性. 但有一例外, 如果该继承属性是一个具有 setter 的访问属性, 则会调用这个访问属性而不是在该对象上创建该属性. 不过调用该 setter 的是当前对象, 而非它的原型对象, 所以在 setter 里面定义的任意属性都只针对对象本身, 而不会影响原型链.

- 如果原型链上有某个属性且该属性为只读, 则不会在当前对象上创建一个同名属性来覆盖这个属性.

- delete 只是断开属性和宿主对象的联系, 不会去操作属性中的属性:

``` js
var a = { p: { x: 1 }};
var b = a;
delete a.p;
console.log(b.x); // 1
```

- delete 只能删除自有属性, 不能删除继承属性.

### 属性检测

- `in`:自有或继承属性都会返回 true
- `hasOwnProperty`: 只有当前属性为自有属性才返回 true
- `propertyIsEnumerable`: 自有属性且为可枚举时才返回 true

### 属性的特性

- 数据属性有四个特性:
  - `value`
  - `writable`
  - `enumerable`
  - `configurable`

- 存取属性的四个特性:
  - `get`
  - `set`
  - `enumerable`
  - `configurable`

## 6.8: 对象的三个属性
### 原型属性

原型属性来是在实例对象创建之初就设置好的, 通过对象的直接量创建的对象使用 Object.prototype 作为它的原型; 通过 new 创建的对象使用构造函数的 prototype 属性作为它的原型; 通过 Object.create 创建的对象使用第一个参数(可以是 null)作为原型.

- 获得原型: `Object.getPrototypeOf()`
- 检测是否是原型(链): `Object.isPrototypeOf()`

### 类属性

默认的 toString 方法(继承自 Object.prototype) 返回 `[object class]` 这种格式的字符串, 因此如果想要获得对象的类, 可以取该字符串的 8 到倒数第二个字符之间的字符串, 不过大多数对象都重新了 toString 方法, 所以只有如下调用:

```js
// P139
function classof(o) {
  if (o === null) return 'Null';
  if (o === undefined) return 'Undefined';
  return Object.prototype.toString.call(o).slice(8, -1);
}
```

### 可扩展性

对象的可扩展性用以表示是否可以给对象添加新属性.

- 检测对象是否可扩展: `Object.isExtensible`
- 使对象不可扩展: `Object.preventExtensions` , 不可逆
- 将对象和对象上所有的自有属性都设置为不可配置: `Object.seal`, 使用 `Object.isSealed` 来检测
  - 除了将对象设置为不可扩展外, 还可以将对象的所有自有属性都设置为不可配置. 也就是说不能给这个对象添加新属性, 而且它已有的属性也不能删除或配置, 不过它已有的可写属性依然可以设置
- 冻结: 除了将对象设置为不可扩展和属性设置为不可配置外, 还可以将它自有的所有数据属性设置为只读(存取器属性具有 setter 的不受影响, 仍然可以通过给属性赋值调用它们): `Object.freeze`, 使用 `Object.isFrozen` 检测


# 数组

- 数组直接量语法允许有可选的结尾逗号，所以 `[,,]`实际上只有2个元素而非3个
- `for...in` 循环顺序不能保证一定是升序， 它会遍历出继承来的可枚举属性， 如果需要判读是否是自有属性，还需要借助 hasOwnProperty 方法。
- 数组的 sort 方法会把 `undefined` 值放到最后。
- concat 不会遍历扁平化数组，例如
  ```js
  var a = [1,2,3];
  a.concat(4,5); // [1,2,3,4,5]
  // 或者
  a.concat([4,5]); // [1,2,3,4,5]
  // 或者
  a.concat([4,5], [6,7]); // [1,2,3,4,5,6,7]
  // 但是不会遍历数组内的数组
  a.concat([4], [5,[6,7]]); // [1,2,3,4,5,[6,7]]
  ```
- slice 返回指定数组的一个片段或者子数组，2个参数分别指定开始和结束位置
- splice 第一个参数指定删除起点，第二个参数指定删除数量， 后面的参数全部为需要插入到数组中的元素。
- 数组的 toString 方法输出不包括任何形式的符号来包裹数组元素，与不带参数的 `join()` 一样，如：
```js
[1,2,3].toString(); // 1,2,3
["a", "b", "c"].toString(); // a,b,c
[1,[2,3]].toString(); // 1,2,3
```
- map 方法返回新数组，不会修改原来的数组，它不会跳过稀疏数组中缺少的元素，返回的也是相同的稀疏数组，即相同长度、相同缺失元素。
- filter 会跳过稀疏数组中缺少的元素，它的返回值总是稠密的。可以使用如下代码压缩稀疏数组：
```js
[,,1,2,,].filter(el => true);
// 如果要过滤掉 null 和 undefined，保留其他 falsy 值：
[,,false, '', 1,2].filter(el => el !== undefined && el != null);
```
- 依据数学惯例，空数组上调用 every 总是返回 true, some 总是返回 false。
- reduce可以用来求最大值，它所接受的函数的 index 和 this 对象从第三个参数开始。
- 字符串类似于数组的事实使得通用的数组方法可以应用于字符串，如：
```
var s = "JavaScript";
Array.prototype.join.call(s, " "); // J a v a S c r i p t
// 只匹配非元音字母
Array.prototype.filter.call(s, x => x.match(/[^aeiou]/)).join(""); // JvScrpt  
```
  - **tip**: 字符串是常量，所以把它们当作参数看待时是只读的。如push，sort，reverse，splice 等数组方法是无效的，并且不会报错！