# 前端零散知识点

## 什么是 MTU

---

## 三次握手四次挥手

TCP 常用报文：

1.  `SYN` （建立连接，Synchronize）
2.  `FIN` （断开连接，Finish）
3.  `RST` （重置连接报文，Reset）
4.  `ACK` （应答，Acknowledge）

          其中 SYN 和 FIN 需要对方收到后用 ACK 应答，而 Reset 和 ACK 无需对方再做出应答。

握手和挥手一般双方（客户端和服务器端）都会生成自己的序列号用于标记请求序列（用于重传或接收，TCP 可靠连接就是靠序列号来达成的），通常通过 `seq` (sequence，建立连接时的 seq 称之为 `isn`，即 initial sequence number，翻译过来为初始序列号)字段发送给对方，而另一方一般会使用 `ack` 来响应对方，`ack` 的值是 `seq` 的值加 `1`，表示当前序列已经接收到，请求发送下一个序列的数据，即 `seq + 1` 的数据（`ack` 是累计的，即 `ack` 之前但不包括 `ack` 是**已经确认被接收到了**的）。

### 三次握手

- 流程：

  - 客户端发起 `SYN` 表示自己希望建立连接（HTTP 规定 SYN 不能发送数据，因此前两次握手无法发送数据，第三次可以）
  - 服务端收到，并响应 `SYN` 和 `ACK`
  - 客户端收到服务器响应，发送 `ACK`，当服务端收到 `ACK` 则成功建立连接。

因此，一个最简单的 HTTP 请求也需要 2 个 RTT（Round-Trip Time） 才能完成

- 为什么要 3 次握手：

  - 需要 3 次握手来确定双方已经成功接收到对方的初始序列号(`ISN`)（参考 [知乎这里的回答](https://www.zhihu.com/question/24853633/answer/573627478)）（个人认为这是最准确的答案，因为它的解释最合理，而且也是来自 RFC 文档）
    1. 客户端发送 `seq` 给服务端
    2. 服务端响应给客户端 `ack`
    3. 服务端发送给客户端自己的 `seq`（由于和上一步都是服务端发送给客户端，因此合并发送 `ack` 和服务器自己的 `seq`，但第一步和第四部无法合并，因此至少需要 3 次握手）
    4. 客户端响应服务端 `ack`
  - 避免因网络拥堵引起的请求后到达导致服务器误以为重新建立连接的情况。（谢希仁在《计算机网络》中的描述）
  - 确保双方的发送和接收能力（即确保发送方和接收方都可以发送和接收数据，如果只是 2 次握手，则至少有一方无法收到回复，也就无法判断是自己成功发送出去还是自己或对方的某一方接收出现了问题）（网友答案，但我个人认为这只是一种副作用而已，3 次握手可以确保这种能力，但并不是 3 次握手的目的）

- 什么是 SYN 攻击（参考链接中关于【[知道 SYN 攻击吗？如何防范？](https://zhuanlan.zhihu.com/p/103000747)】部分）
  - 原理：由于服务端收到 SYN 报文并响应 SYN/ACK 报文时会分配连接缓存，攻击者通过大量虚假 IP 向服务器发送 SYN 报文导致服务器分配太多缓存却无法收到回复，从而不停的发送 SYN/ACK 直到关闭连接
  - 解决方案：收到第三次 ACK 后再分配缓存

### 四次挥手

- 流程：

  - 客户端发起 `FIN` 希望断开 `客户端 -> 服务端` 方向的连接
  - 服务端收到后响应 `ACK` 表示可以断开，客户端进入 FIN-WAIT-2 状态等待服务端发出断开请求
  - 服务端发出 `FIN` 和 `ACK` 表示可以断开 `服务器 -> 客户端` 的连接（为什么要发送 `ACK` 呢？个人认为主要是解决第二步 ACK 报文丢失的情况）
  - 客户端响应 `ACK` 表示可以断开，然后整个断开过程完成

- 为什么要四次挥手
  - 因为 TCP 是`双向`的，每两次挥手用于断开其中一个方向的数据传输。
  - 前两次挥手用于关闭 `客户端 -> 服务器` 方向的数据发送，断开之后客户端不可再向服务器发送数据，但是 `服务器 -> 客户端` 还未断开，因此服务器还可以向客户端发送数据，所以还需要再断开 `服务器 -> 客户端` 方向的数据发送。
  - 中间的两次是无法合并的，因为第二次是服务端回应 `客户端 -> 服务端` 方向的连接可以断开，而第三次是服务端通知客户端断开连接，第二次只是表明从客户端到服务端的数据不会在发送了，而可能此时服务端还在向客户端发送数据或者稍后还会发送数据，因此暂时还不可以发送第三次挥手

参考资料：

- https://www.zhihu.com/question/24853633/answer/573627478
- https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ
- https://segmentfault.com/a/1190000021494676?utm_source=sf-similar-article
- https://zhuanlan.zhihu.com/p/103000747

---

## HTTPS

首先需要明确：

- `对称加密`：同一个秘钥，加密解密都用它，加解密执行效率较高
- `非对称加密`：分为`公钥`（可以给任何人）和`私钥`（只能自己持有），`公钥`加密只能`私钥`解密，`私钥`加密需要`公钥`解密，加解密执行效率较低

客户端首先从服务器获取证书，由于证书是 CA 机构（证书认证机构）签发 _（其中包含申请者的公钥，组织信息，域名信息等 ）_ ，因此可以使用浏览器或操作系统内集成的常见 CA 机构的公钥进行验证，验证通过之后则获得证书公钥 _（引入 CA 验证的证书可以防止公钥被中间人拦截，因为浏览器只知道自己从服务器拿到了公钥，并不知道在获取的过程中公钥是否已经被拦截和篡改，如果是已经篡改过的公钥，那将会导致浏览器用这个公钥一直错下去，它可能一直以为自己拿到的就是正确的公钥）_。

由于非对称加密性能较差，对称加密解密更快，因此 https 采用二者结合的方式。客户端获取到公钥之后，会随机生成一个**对称加密**的秘钥，然后用服务器给的公钥进行加密，再将加密结果发送给服务器，服务器收到之后使用私钥进行解密从而获得其中的**对称加密**的秘钥，然后使用对称加密来进行通信，从而提升效率！

个人认为其中核心部分就是围绕 **_如何安全的交换对称加密的秘钥_**

用更直观的话来归纳就是：

`客户端从服务器获取证书 -> 使用浏览器或操作系统集成的CA公钥验证证书并获取证书中携带的服务器公钥 -> 生成对称加密的秘钥并用服务器公钥加密后发送给服务端 -> 服务端使用私钥解密获得对称加密的秘钥 -> 双方使用对称加密发送数据`

参考资料：

- [这是一篇人人都看的懂 HTTPS 的文章](https://juejin.cn/post/6906443847811907597)
- [看完这篇 HTTPS，和面试官扯皮就没问题了](https://juejin.cn/post/6844904089495535624)
- [刨根问底系列之 https 到底是如何防篡改的？](https://juejin.cn/post/6845166890675863559)

### 关于 HTTPS 握手

HTTPS 在 TCP 基础之上，因此 **首先完成 TCP 的三次握手建立连接**，然后再：

1. 客户端发送 `Client Hello` 握手协议，其中包含 `TSL 协议版本`(Version)、`客户端生成的用于后续秘钥协商的随机数`(Random),`加密套件可选列表`(Cipher Suites)、`压缩算法可选列表`(Compression Methods)、扩展字段以及其它
2. 服务端发送 `Server Hello` 握手协议，并返回协商结果，其中包含：`TSL 协议版本`(Version)、`服务端生成的随机数`(Random)、`选定的加密套件`(Cipher Suite)、`选定的压缩算法`(Compression Method)
3. 服务端发送自己的证书（由于证书可能较大，因此可能分多个报文发送）
4. 服务端发送 `Server Key Exchange`（可能会发送，因 TSL 加密算法而异，某些算法不会发送）
5. 服务端发送 `Server Hello Done` 通知客户端 `Server Hello` 结束
6. 客户端发送 `Client Key Exchange`，到这一步客户端已经计算出了通信秘钥，因此向服务器发送自己的秘钥参数（经过服务器公钥加密），并告诉服务端此后都使用协商的秘钥和加密算法来进行通信，与此同时还有 `Change Cipher Spec`，并通过 `Encrypted Handshake Message` 测试秘钥的有效性和一致性
7. 服务端发送 `New Session Ticket`，给客户端开辟一段会话，在超时时间到来之前都在该会话中使用约定的秘钥和加密算法通信
8. 服务端发送 change_cipher_spec，此步骤为服务端拿到了第 6 步中客户端发过来的参数并计算好了通信秘钥，并且已经通过客户端发送的 `Encrypted Handshake Message` 验证完了有效性，该报文的目的是通知客户端服务端确认了通信秘钥，之后可以以该秘钥进行通信
9. 服务端发送 `Encrypted Handshake Message`，该报文同样是验证客户端是否能正常解密以及服务端是否能正常加密
10. 协商完成，开发发送数据！

归纳一下上面的流程，在 TCP 三次握手建立连接之后：

`客户端发送 Client Hello 提供给服务端可选的加密套件和秘钥随机数等参数` -> `服务端选定需要使用的加密套件和自己的随机数参数并通过 Server Hello 报文发送给客户端` -> `服务端发送自己的证书` -> `通知客户端 Server Hello Done (完成)` -> `客户端根据随机数等计算出用于发送数据的对称秘钥并让服务器验证加解密是否正确` -> `服务端为客户端开辟会话` -> `服务端计算出对称秘钥并验证完成，同样再让客户端验证自己的加解密是否正确` -> `协商完成，开始发送数据`

另一种更简洁的方式，引用阮一峰在该文章中给的示例：

> 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（`Client random`），以及客户端支持的加密方法。

> 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（`Server random`）。

> 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（`Premaster secret`），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。

> 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即 `Premaster secret`）。

> 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（`session key`），用来加密接下来的整个对话过程。

可以看出上面用于对话的秘钥中，只有第三个随机数（`Premaster secret`）是需要证书解密的，这也是 Cloudflare 为什么可以提供 Keyless 服务的原因（CDN 服务商请求客户服务器解密 `Premaster secret` 即可，后面的工作就交给 CDN 服务商去完成）。

参考文档：

- [图解 SSL/TLS 协议 —— 阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
- [刨根问底系列之 https 详细握手过程](https://juejin.cn/post/6847902219745181709)

---

## HTTP2

一般 HTTP2 之前每个请求大部分都是短连接，即 `握手 -> 请求数据 -> 挥手断开` 这种方式，但浏览器对同一个域名下的并发请求数有限制，通常是 6-8 个，且每次需要经过 `握手` 的过程，还会经历 TCP 慢启动等中间过程，导致对网络的利用率大幅下降。因此出现了 HTTP2。它针对传输过程进行了一些升级优化，如头部压缩、二进制传输等，它可以复用同一个 TCP 请求，从而减少了不必要的 `握手`、并发数限制、每次都需要慢启动 等过程，从而提升性能。

相较于 HTTP1.1 优化：

- 多路复用
  - 虽然 HTTP1.0 有 `connection: keep-alive`（HTTP1.0 默认关闭，HTTP1.1 默认开启，通过 `Connection: close`关闭）；但是可能造成`头部拥塞`（即前面的数据如果发生拥堵，后面的数据只能等待它）。但是 HTTP2 是通过 stream 封装消息的方式发送， stream 头部有携带 streamId 用于对请求进行区分和还原
- 头部压缩
  - 虽然 HTTP2 之前能压缩请求中的请求体，但是无法压缩请求头，使用 HTTP2 的 HPACK 算法（通过静态字典、动态字典的方式，双方记录一份字典，节省字段发送）对头部进行压缩能够节省 40% - 90% 流量
- 服务端主动 push
  - 某些资源是可预测的，例如当网页加载了 HTML 之后，很可能会加载首屏的 CSS 或者 JS 文件，可以通过服务端主动 push 的方式主动将内容发送给客户端（一般需要服务器配置哪些资源需要跟着某个资源 push）
  - 关于主动 push 缓存的问题可以参考 [HTTP/2 对现在的网页访问，有什么大的优化呢？体现在什么地方？ - leozhang2018 的回答 - 知乎](https://www.zhihu.com/question/24774343/answer/96586977)

参考资料：

- [HTTP/2 资料汇总](https://imququ.com/post/http2-resource.html)
- [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)
- [HTTP/2 对现在的网页访问，有什么大的优化呢？体现在什么地方？ - leozhang2018 的回答 - 知乎](https://www.zhihu.com/question/24774343/answer/96586977)

---

## OSI 7 层模型

OSI 即 Open System Interconnect，开放系统互联。

（应表会传网数物）

- `应用层`：为上层应用提供网络接口

  - 代表协议有 HTTP、FTP、POP3、DHCP、TFTP、NFS、WAIS

- `表示层`：数据的表示、安全、压缩。

  - Telnet、Gopher、Rlogin、SNMP

- `会话层`：建立、管理、终止会话

  - SMTP、DNS

- `传输层`：定义传输数据的协议端口号，以及流控和差错校验，数据包一旦离开网卡即进入网络传输层

  - TCP、UDP

- `网络层`：进行逻辑地址寻址，实现不同网络之间的路径选择。

  - IP、ICMP、ARP、RARP、AKP、UUCP

- `数据链路层`：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用 MAC 地址访问介质，错误发现但不能纠正。

  - FDDI、Ethernet、Arpanet、PDN、SLIP、PPP

- `物理层`：建立、维护、断开物理连接。(发送 010101 这样的数据到网络)

  - IEEE 802.1A、IEEE 802.2 到 IEEE 802.11

可以这里理解（自下而上）：

- `物理层`负责发送比特流，即 010101 这样的数据
- `数据链路层`是向局域网内广播数据，其标头会携带 MAC 地址，接收方收到后和自己的 MAC 地址进行比较，如果相同则接收，否则丢弃（但是链路层只能局限在局域网中广播，不同局域网无法发送，因此需要网络层），相当于是建立 `MAC <=> MAC` 之间的通信
- `网络层`是逻辑地址，即 IP 地址寻址（其标头会携带 IP 地址信息），它用于定位子网，建立 `主机 <=> 主机` 之间的通信（该层包含 ARP 协议，其目的是通过网络层地址（IP 地址）来寻找数据链路层地址（MAC 地址）的协议）
- `传输层`，定位端口（TCP/UDP，其标头会包含端口号），相当于是建立 `端口 <=> 端口` 之间的通信
- `应用层`

### TCP/IP 5 层模型

将 7 层模型中的前三层合并为统称为应用层，即变成 5 层模型

参考资料：

- [2018 网络编程基础恶补篇](https://www.bilibili.com/video/BV1ys411H77H?p=1)

---

## HTTP 缓存

HTTP 缓存分为`强制缓存`和`协商缓存`，当前置缓存和协商缓存同时存在的时候，优先使用强制缓存。

- `协商缓存`：会先发送请求给服务端判断缓存是否过期
- `强制缓存`：直接使用缓存，无需发送请求确认

### 协商缓存

- `Last-Modified`：资源最后修改的时间，服务端通过 HTTP 响应头发送给客户端，客户端下次请求该资源时携带 `If-Modified-Since` 请求头，其值为服务器最后一次响应给客户端的 `Last-Modified` 值。服务端收到该值会检查文件的最后修改时间，如果时间大于该值则返回 `200` 加文件内容，如果小于该值则返回 `304`

- `ETag`（由于直接是文件 hash，几乎是 100%准确的，优先级高于 `Last-Modified`）：资源文件内容的 hash 值，服务端会将该值通过 HTTP 响应头发送给客户端，客户端下次对该资源发起请求的时候会使用 `If-None-Match` 携带该值。服务端收到后会校验该值和当前文件的 hash 是否相同，如果不同说明文件已经发生改变，返回 `200` 和文件内容，否则返回 `304`

#### 优先级：

每次修改文件都会导致 `ETag` 发生改变，但是 `Last-Modified` 仅能精确到秒，因此 `ETag` 更加精确。

#### 存在的问题：

- `Last-Modified` 只能精确到秒，如果太频繁（1 秒中执行多次）的请求将无能为力
- `ETag` 在每次请求服务端都会生成 hash 校验文件，从而导致消耗过多服务端资源

### 强制缓存

- `Expires`：服务端通过响应头返回给客户端的一个日期值，表示在此时间之前直接使用缓存，不用发起任何请求

  - 存在问题：由于返回的时间是一个绝对时间，如果客户端时间与服务器时间不同步将导致缓存异常，因此可以考虑下面的 `Cache-Control` 中的 `max-age`

- [`Cache-Control`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)：
  - `max-age`：缓存的时间（优先级高于 `Expires`）
  - `no-cache`：协商缓存，即需要发起请求确认是否使用缓存
  - `no-store`：不缓存任何内容
  - `public`：任何内容和节点都可以缓存，即使是一般不缓存的内容（例如 POST 请求）
  - `private`：代理节点不缓存内容，仅客户端这类私有缓存可以缓存请求内容
  - `immutable`：资源不会过期，即永久缓存（实验性，兼容性可能不太好）
  - 其它属性参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)

参考资料：

- [轻松理解 HTTP 缓存策略](https://segmentfault.com/a/1190000038562294)

---

## 浏览器安全

### 攻击手段

#### `CSRF`（Cross-site request forgery，跨站请求伪造）

一个 CSRF 攻击需要 2 个条件：

1. 用户登录了一个受信任的网站 A，其登录信息存放在 Cookie 中
2. 在 A 未退出登录的情况下，（被诱导或主动）访问了危险网站 B；此时 B 网站通过构造 Img 标签的 src（这类方式针对 GET 类型的接口）或者构建了一个表单并自动提交（针对 POST 类型的接口）来调用 A 网站的接口（如转账、增删改查等操作），从而完成了 CSRF 共计。

其利用了浏览器会自动携带 Cookie 的特点完成攻击。但是较高版本的浏览器已经将 Cookie 中 `Same-Site` 的值默认设置为了 Lax（以前为 None），将不会在跨站情况下自动携带 Cookie

##### 防御：

- 加入`验证码`
- 验证 `Referer`
- 加入自定义 `Header`
- 注入 `Token` 到页面中并在请求中携带
- `Cookie` 中 `Same-Site` 设置为 `Strict` 或者 `Lax`（新版浏览器中的默认值）

#### `XSS`（Cross-site scripting，跨站脚本攻击）

XSS 攻击主要是注入恶意脚本，例如某个论坛网站有一个 `text-area` 用于用户输入评论，某个用户输入了 `<script>alert(1)</script>` 这样的代码，但是网站并未做过滤，直接显示了内容，如 `comment.innerHTML = {{input}}` 会导致输出的内容为 `<div id="comment"><script>alert(1)</script></div>`，这相当于是嵌入了一段 JavaScript 代码并自动执行，恶意代码可以做任何事情！

一般主要分为存储型、反射型（我个人觉得原理都一样，只是实现方式不一样，完全没必要按这种方式去区分）：

- 存储型：数据会发送到后台服务器进行保存，下次会发送给前端
- 反射型：例如通过 URL 携带恶意脚本代码，页面直接从 URL 参数中取出显示到页面上导致脚本执行
- 基于 DOM：拦截修改 DOM 注入代码

##### 防御：

- 前后端都可以对内容进行过滤或者转义，前端可以使用 `textContent` 而非 `innerHTML`，`textContent` 性能更高，因为它的内容不会被解析为 HTML，因此也避免了 `XSS` 攻击
- Cookie 添加 `HttpOnly`（个人觉得这很鸡肋，毕竟只能防止 js 获取到 cookie，但是已经注入脚本了，完全没必要再获取 cookie，直接发请求执行操作就可以了，太过于牵强）
- 配置 CSP 策略：参考 [Content Security Policy 入门教程 —— 阮一峰](http://www.ruanyifeng.com/blog/2016/09/csp.html)
  - 设置 `nonce`

### 防御手段

#### [CSP](http://www.ruanyifeng.com/blog/2016/09/csp.html)

CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。

启动方式：

- 通过 HTTP 头信息的`Content-Security-Policy`的字段
  - 如 `Content-Security-Policy: script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:`
- 另一种是通过网页的`<meta>`标签
  - 如 `<meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:">`

可以限制哪些资源可以加载，如何加载（http 或者 https，从哪里加载），哪些脚本可以执行，如何执行（如是否允许使用 `eval`，是否需要匹配 `nonce`）等，参数太多，如果有兴趣可以阅读下面罗列的参考资料。

参考资料：

- [Content Security Policy 入门教程 —— 阮一峰](http://www.ruanyifeng.com/blog/2016/09/csp.html)

---

## 兼容性

1、`addEventListener` 与 `attachEvent` 区别

- `attachEvent` 兼容：IE7、IE8；不兼容 firefox、chrome、IE9、IE10、IE11、safari、opera。
- `addEventListener`兼容：firefox、chrome、IE、safari、opera；不兼容 IE7、IE8 解决方案：

```js
function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    // W3C标准
    elm.addEventListener(evType, fn, useCapture);
    return true;
  } else if (elm.attachEvent) {
    // IE
    var r = elm.attachEvent("on" + evType, fn); // IE5+
    return r;
  } else {
    elm["on" + evType] = fn; // DOM事件
  }
}
```

直接查看以下参考资料

参考资料：

- [浏览器的兼容问题及解决方案整理（建议收藏）](https://juejin.cn/post/6972937716660961317)

---

## 浏览器内核

- Blink：新版 Chrome、Opera 使用该内核
- Webkit：苹果自研内核，Safari 以及早期 Chrome 和 Opera 使用该内核
- Gecko：火狐
- Trident（微软）：IE
- Presto（已废弃）：早期 Opera 自研内核

更多故事参考：

- [浏览器内核 —— 百度百科](https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/10602413)

---

## Express 洋葱模型

---

## 浏览器跨域

### `CORS`（Cross-origin resource sharing，跨站资源共享）

最初 Ajax 只能同源发送请求，但随着日益复杂的前端场景，经常可能需要从跨域站点获取数据请求，早期出现了一些如 JSONP 之类的跨站技术，不过现在已经有 CORS 更加规范的来进行跨站资源共享，从而解决的 Ajax 必须同源的限制

浏览器将 CORS 请求分为两类：

- `简单请求`
- `非简单请求`

对于 CORS 请求，浏览器会自动添加 `Origin` 头，其值为当前发生请求的域：`协议` + `域名` + `端口`。
当接收到响应如果当前域不包含在响应头中的 `Access-Control-Allow-Origin` 字段所指定的范围，则抛出跨域异常。

#### 简单请求

同时满足以下条件即为简单请求（该设计是为了兼容表单，因为表单可以发送跨域请求，只要表单可以发的 Ajax 就要可以发）

1. `HEAD`、`GET`、`POST` 之一
2. Header 字段不超出：`Accept`、`Accept-Language`、`Content-Language`、`Last-Event-ID`
3. `Content-Type` 只限于以下三个值（表单支持的三种 [MIME 类型](http://en.wikipedia.org/wiki/Mime_type)）

   - `application/x-www-form-urlencoded`：默认值，表示表单数据已经被编码为 URL 参数格式，就像 `txt1=hello&txt2=world` 这样
   - `multipart/form-data`：表单包含 `type=file` 的 `input` 元素时使用，消息体会被分割为多个部分的 `form-data`
   - `text/plain`：出现于 HTML5，纯文本格式

#### 非简单请求

非简单请求如 `PUT`、`DELETE` 这一类会对服务器产生副作用的请求或者 `Content-Type` 为 `application/json`。浏览器如果发现是非简单请求，则会发送一个预检请求 `OPTIONS` 用于向后端确认接下来的请求是否被允许，其会向后端询问：

- `Access-Control-Request-Method`：是否允许该字段中罗列的请求，后端会通过 `Access-Control-Allow-Methods` 列出允许的请求，可能会列出多个来减少后续预检
- `Access-Control-Request-Headers`：罗列出自定义请求头，询问后端是否允许这些自定义请求头，后端会通过响应中的 `Access-Control-Allow-Headers` 头进行回应

响应头中还包含：

- `Access-Control-Allow-Origin`（必须）：表示允许发起请求的源，它可以是请求头中的 `Origin` 字段，也可能是 `*`，但是如果浏览器携带了 cookie 则不能是 `*`，必须与发起请求的源一致。
- `Access-Control-Allow-Credentials`：是否允许携带 cookie，需要前端配合，如 Ajax 中设置 `withCredentials: true`;
- `Access-Control-Max-Age`：本次预检请求的有效期，在有效期内不用再次发起预检请求

浏览器在预检中发起的头部一般是 `Access-Control-Request-` 开头表示询问服务器是否允许对应的字段，服务器响应的时候对应的就是 `Access-Control-Allow-` 表示允许，差别就在于一个是 `Request` 一个是 `Allow`，其它部分相同。

### `JSONP`

利用浏览器加载 JavaScript 文件会自动执行的特点，返回带有回调函数（回调函数名称和前端约定好，通过 GET 参数传给后端）的 JavaScript 源文件，参数通过回调函数参数传入。

#### 优点：

- 兼容性好，支持 IE5

#### 缺点：

- 仅兼容 `GET` 方式，无法使用 `POST` 请求。

### `WebSocket`

`WebSocket` 并不实行同源策略，只要服务器支持就可以通过它进行跨域通信。其发起时头部会携带 `Origin` 向后端表明自己是从哪个网站发起的请求。

---
