# 前端零散知识点

## 什么是 MTU

---

## 三次握手四次挥手

TCP 常用报文：

1.  `SYN` （建立连接，Synchronize）
2.  `FIN` （断开连接，Finish）
3.  `RST` （重置连接报文，Reset）
4.  `ACK` （应答，Acknowledge）

          其中 SYN 和 FIN 需要对方收到后用 ACK 应答，而 Reset 和 ACK 无需对方再做出应答。

握手和挥手一般双方（客户端和服务器端）都会生成自己的序列号用于标记请求序列（用于重传或接收，TCP 可靠连接就是靠序列号来达成的），通常通过 `seq` (sequence，建立连接时的 seq 称之为 `isn`，即 initial sequence number，翻译过来为初始序列号)字段发送给对方，而另一方一般会使用 `ack` 来响应对方，`ack` 的值是 `seq` 的值加 `1`，表示当前序列已经接收到，请求发送下一个序列的数据，即 `seq + 1` 的数据（`ack` 是累计的，即 `ack` 之前但不包括 `ack` 是**已经确认被接收到了**的）。

### 三次握手

- 流程：

  - 客户端发起 `SYN` 表示自己希望建立连接（HTTP 规定 SYN 不能发送数据，因此前两次握手无法发送数据，第三次可以）
  - 服务端收到，并响应 `SYN` 和 `ACK`
  - 客户端收到服务器响应，发送 `ACK`，当服务端收到 `ACK` 则成功建立连接。

因此，一个最简单的 HTTP 请求也需要 2 个 RTT（Round-Trip Time） 才能完成

- 为什么要 3 次握手：

  - 需要 3 次握手来确定双方已经成功接收到对方的初始序列号(`ISN`)（参考 [知乎这里的回答](https://www.zhihu.com/question/24853633/answer/573627478)）（个人认为这是最准确的答案，因为它的解释最合理，而且也是来自 RFC 文档）
    1. 客户端发送 `seq` 给服务端
    2. 服务端响应给客户端 `ack`
    3. 服务端发送给客户端自己的 `seq`（由于和上一步都是服务端发送给客户端，因此合并发送 `ack` 和服务器自己的 `seq`，但第一步和第四部无法合并，因此至少需要 3 次握手）
    4. 客户端响应服务端 `ack`
  - 避免因网络拥堵引起的请求后到达导致服务器误以为重新建立连接的情况。（谢希仁在《计算机网络》中的描述）
  - 确保双方的发送和接收能力（即确保发送方和接收方都可以发送和接收数据，如果只是 2 次握手，则至少有一方无法收到回复，也就无法判断是自己成功发送出去还是自己或对方的某一方接收出现了问题）（网友答案，但我个人认为这只是一种副作用而已，3 次握手可以确保这种能力，但并不是 3 次握手的目的）

- 什么是 SYN 攻击（参考链接中关于【[知道 SYN 攻击吗？如何防范？](https://zhuanlan.zhihu.com/p/103000747)】部分）
  - 原理：由于服务端收到 SYN 报文并响应 SYN/ACK 报文时会分配连接缓存，攻击者通过大量虚假 IP 向服务器发送 SYN 报文导致服务器分配太多缓存却无法收到回复，从而不停的发送 SYN/ACK 直到关闭连接
  - 解决方案：收到第三次 ACK 后再分配缓存

### 四次挥手

- 流程：

  - 客户端发起 `FIN` 希望断开 `客户端 -> 服务端` 方向的连接
  - 服务端收到后响应 `ACK` 表示可以断开，客户端进入 FIN-WAIT-2 状态等待服务端发出断开请求
  - 服务端发出 `FIN` 和 `ACK` 表示可以断开 `服务器 -> 客户端` 的连接（为什么要发送 `ACK` 呢？个人认为主要是解决第二步 ACK 报文丢失的情况）
  - 客户端响应 `ACK` 表示可以断开，然后整个断开过程完成

- 为什么要四次挥手
  - 因为 TCP 是`双向`的，每两次挥手用于断开其中一个方向的数据传输。
  - 前两次挥手用于关闭 `客户端 -> 服务器` 方向的数据发送，断开之后客户端不可再向服务器发送数据，但是 `服务器 -> 客户端` 还未断开，因此服务器还可以向客户端发送数据，所以还需要再断开 `服务器 -> 客户端` 方向的数据发送。
  - 中间的两次是无法合并的，因为第二次是服务端回应 `客户端 -> 服务端` 方向的连接可以断开，而第三次是服务端通知客户端断开连接，第二次只是表明从客户端到服务端的数据不会在发送了，而可能此时服务端还在向客户端发送数据或者稍后还会发送数据，因此暂时还不可以发送第三次挥手

参考资料：

- https://www.zhihu.com/question/24853633/answer/573627478
- https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ
- https://segmentfault.com/a/1190000021494676?utm_source=sf-similar-article
- https://zhuanlan.zhihu.com/p/103000747

---

## HTTPS

首先需要明确：

- `对称加密`：同一个秘钥，加密解密都用它，加解密执行效率较高
- `非对称加密`：分为`公钥`（可以给任何人）和`私钥`（只能自己持有），`公钥`加密只能`私钥`解密，`私钥`加密需要`公钥`解密，加解密执行效率较低

客户端首先从服务器获取证书，由于证书是 CA 机构（证书认证机构）签发 _（其中包含申请者的公钥，组织信息，域名信息等 ）_ ，因此可以使用浏览器或操作系统内集成的常见 CA 机构的公钥进行验证，验证通过之后则获得证书公钥 _（引入 CA 验证的证书可以防止公钥被中间人拦截，因为浏览器只知道自己从服务器拿到了公钥，并不知道在获取的过程中公钥是否已经被拦截和篡改，如果是已经篡改过的公钥，那将会导致浏览器用这个公钥一直错下去，它可能一直以为自己拿到的就是正确的公钥）_。

由于非对称加密性能较差，对称加密解密更快，因此 https 采用二者结合的方式。客户端获取到公钥之后，会随机生成一个**对称加密**的秘钥，然后用服务器给的公钥进行加密，再将加密结果发送给服务器，服务器收到之后使用私钥进行解密从而获得其中的**对称加密**的秘钥，然后使用对称加密来进行通信，从而提升效率！

个人认为其中核心部分就是围绕 **_如何安全的交换对称加密的秘钥_**

用更直观的话来归纳就是：

`客户端从服务器获取证书 -> 使用浏览器或操作系统集成的CA公钥验证证书并获取证书中携带的服务器公钥 -> 生成对称加密的秘钥并用服务器公钥加密后发送给服务端 -> 服务端使用私钥解密获得对称加密的秘钥 -> 双方使用对称加密发送数据`

参考资料：

- [这是一篇人人都看的懂 HTTPS 的文章](https://juejin.cn/post/6906443847811907597)
- [看完这篇 HTTPS，和面试官扯皮就没问题了](https://juejin.cn/post/6844904089495535624)
- [刨根问底系列之 https 到底是如何防篡改的？](https://juejin.cn/post/6845166890675863559)

### 关于 HTTPS 握手

HTTPS 在 TCP 基础之上，因此 **首先完成 TCP 的三次握手建立连接**，然后再：

1. 客户端发送 `Client Hello` 握手协议，其中包含 `TSL 协议版本`(Version)、`客户端生成的用于后续秘钥协商的随机数`(Random),`加密套件可选列表`(Cipher Suites)、`压缩算法可选列表`(Compression Methods)、扩展字段以及其它
2. 服务端发送 `Server Hello` 握手协议，并返回协商结果，其中包含：`TSL 协议版本`(Version)、`服务端生成的随机数`(Random)、`选定的加密套件`(Cipher Suite)、`选定的压缩算法`(Compression Method)
3. 服务端发送自己的证书（由于证书可能较大，因此可能分多个报文发送）
4. 服务端发送 `Server Key Exchange`（可能会发送，因 TSL 加密算法而异，某些算法不会发送）
5. 服务端发送 `Server Hello Done` 通知客户端 `Server Hello` 结束
6. 客户端发送 `Client Key Exchange`，到这一步客户端已经计算出了通信秘钥，因此向服务器发送自己的秘钥参数（经过服务器公钥加密），并告诉服务端此后都使用协商的秘钥和加密算法来进行通信，与此同时还有 `Change Cipher Spec`，并通过 `Encrypted Handshake Message` 测试秘钥的有效性和一致性
7. 服务端发送 `New Session Ticket`，给客户端开辟一段会话，在超时时间到来之前都在该会话中使用约定的秘钥和加密算法通信
8. 服务端发送 change_cipher_spec，此步骤为服务端拿到了第 6 步中客户端发过来的参数并计算好了通信秘钥，并且已经通过客户端发送的 `Encrypted Handshake Message` 验证完了有效性，该报文的目的是通知客户端服务端确认了通信秘钥，之后可以以该秘钥进行通信
9. 服务端发送 `Encrypted Handshake Message`，该报文同样是验证客户端是否能正常解密以及服务端是否能正常加密
10. 协商完成，开发发送数据！

归纳一下上面的流程，在 TCP 三次握手建立连接之后：

`客户端发送 Client Hello 提供给服务端可选的加密套件和秘钥随机数等参数` -> `服务端选定需要使用的加密套件和自己的随机数参数并通过 Server Hello 报文发送给客户端` -> `服务端发送自己的证书` -> `通知客户端 Server Hello Done (完成)` -> `客户端根据随机数等计算出用于发送数据的对称秘钥并让服务器验证加解密是否正确` -> `服务端为客户端开辟会话` -> `服务端计算出对称秘钥并验证完成，同样再让客户端验证自己的加解密是否正确` -> `协商完成，开始发送数据`

另一种更简洁的方式，引用阮一峰在该文章中给的示例：

> 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（`Client random`），以及客户端支持的加密方法。

> 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（`Server random`）。

> 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（`Premaster secret`），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。

> 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即 `Premaster secret`）。

> 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（`session key`），用来加密接下来的整个对话过程。

参考文档：

- [图解 SSL/TLS 协议 —— 阮一峰](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
- [刨根问底系列之 https 详细握手过程](https://juejin.cn/post/6847902219745181709)

---

## HTTP2

一般 HTTP2 之前每个请求大部分都是短连接，即 `握手 -> 请求数据 -> 挥手断开` 这种方式，但浏览器对同一个域名下的并发请求数有限制，通常是 6-8 个，且每次需要经过 `握手` 的过程，还会经历 TCP 慢启动等中间过程，导致对网络的利用率大幅下降。因此出现了 HTTP2。它针对传输过程进行了一些升级优化，如头部压缩、二进制传输等，它可以复用同一个 TCP 请求，从而减少了不必要的 `握手`、并发数限制、每次都需要慢启动 等过程，从而提升性能。

相较于 HTTP1.1 优化：

- 多路复用
  - 虽然 HTTP1.0 有 `connection: keep-alive`（HTTP1.0 默认关闭，HTTP1.1 默认开启，通过 `Connection: close`关闭）；但是可能造成`头部拥塞`（即前面的数据如果发生拥堵，后面的数据只能等待它）。但是 HTTP2 是通过 stream 封装消息的方式发送， stream 头部有携带 streamId 用于对请求进行区分和还原
- 头部压缩
  - 虽然 HTTP2 之前能压缩请求中的请求体，但是无法压缩请求头，使用 HTTP2 的头部压缩能够节省 40% - 90% 流量
- 服务端主动 push
  - 某些资源是可预测的，例如当网页加载了 HTML 之后，很可能会加载首屏的 CSS 或者 JS 文件，可以通过服务端主动 push 的方式主动将内容发送给客户端（一般需要服务器配置哪些资源需要跟着某个资源 push）
  - 关于主动 push 缓存的问题可以参考 [HTTP/2 对现在的网页访问，有什么大的优化呢？体现在什么地方？ - leozhang2018 的回答 - 知乎](https://www.zhihu.com/question/24774343/answer/96586977)

参考资料：

- [HTTP/2 资料汇总](https://imququ.com/post/http2-resource.html)
- [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)
- [HTTP/2 对现在的网页访问，有什么大的优化呢？体现在什么地方？ - leozhang2018 的回答 - 知乎](https://www.zhihu.com/question/24774343/answer/96586977)

---

## OSI 7 层模型

OSI 即 Open System Interconnect，开放系统互联。

（应表会传网数物）

- `应用层`：为上层应用提供网络接口

  - 代表协议有 HTTP、FTP、POP3、DHCP、TFTP、NFS、WAIS

- `表示层`：数据的表示、安全、压缩。

  - Telnet、Gopher、Rlogin、SNMP

- `会话层`：建立、管理、终止会话

  - SMTP、DNS

- `传输层`：定义传输数据的协议端口号，以及流控和差错校验，数据包一旦离开网卡即进入网络传输层

  - TCP、UDP

- `网络层`：进行逻辑地址寻址，实现不同网络之间的路径选择。

  - IP、ICMP、ARP、RARP、AKP、UUCP

- `数据链路层`：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用 MAC 地址访问介质，错误发现但不能纠正。

  - FDDI、Ethernet、Arpanet、PDN、SLIP、PPP

- `物理层`：建立、维护、断开物理连接。

  - IEEE 802.1A、IEEE 802.2 到 IEEE 802.11

### TCP/IP 5 层模型

将 7 层模型中的前三层合并为统称为应用层，即变成 5 层模型

---
