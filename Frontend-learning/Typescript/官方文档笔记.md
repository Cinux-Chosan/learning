## [接口](http://www.typescriptlang.org/docs/handbook/interfaces.html)
- 变量用 const, 属性用 readonly
- Readonly 的元素不能赋值给其他值，如果需要赋值可以使用类型断言：`a = ro as number[];`，ro 即一个 readonly 变量
- ts 对对象字字面量会严格校验其类型, 比如在赋值或者传参时。此时可以使用类型断言 `let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);`，SquareConfig 是 `interface SquareConfig { width?: number }`
  - 但更好的方式是定义一个索引签名：
  ```ts
    interface SquareConfig {
        color?: string;
        width?: number;
        [propName: string]: any;
    }
  ```
- 定义函数类型接口：
  ```ts
    interface SearchFunc {
    (source: string, subString: string): boolean;
    }
  ```
- 字符串索引会强制所有其他属性使用它的类型：
  ```ts
    interface NumberDictionary {
        [index: string]: number;
        length: number;    // ok, length is a number
        name: string;      // error, the type of 'name' is not a subtype of the indexer
    }
  ```
  - 另外，如果将其定义为只读，则就变成了 `ReadonlyArray<T>`：
  ```ts
    interface ReadonlyStringArray {
        readonly [index: number]: string;
    }
    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
    myArray[2] = "Mallory"; // error!
  ```
- 接口只对类的公有属性进行校验，不会私有属性进行校验。
- 类实现接口时，接口只会对类的实例级属性进行匹配，而类中的构造函数属于静态属性而非实例属性，因此接口中定义的构造函数签名 `new (prop: string);` 无法与类中的构造函数进行匹配，这就导致报错。
- 接口可以继承类，它在继承类的时候只继承其声明，而不继承其实现，其中包括私有成员和保护成员。这就意味着如果你通过继承一个具有私有或保护属性的类创建了一个接口，那这个接口只能被这个类及其子类实现。因为只有其子类才具有和基类同一声明来源的属性。

## [类](http://www.typescriptlang.org/docs/handbook/classes.html)

- ts 是一个结构类型系统，如果我们对两个类型进行比较，如果它其中的所有类型都兼容，则认为这两个是兼容的。但是如果比较的类型包含了 `private` 或者 `protected` 成员，则 ts 会以不同的方式来处理它们：如果要认为两个类型是兼容的，其中一个具有私有或者保护属性时，另一个也必须有和它**相同来源**的私有或者保护属性。
  ```ts
    class Animal {
        private name: string;
        constructor(theName: string) { this.name = theName; }
    }

    class Rhino extends Animal {
        constructor() { super("Rhino"); }
    }

    class Employee {
        private name: string;
        constructor(theName: string) { this.name = theName; }
    }

    let animal = new Animal("Goat");
    let rhino = new Rhino();
    let employee = new Employee("Bob");

    animal = rhino;
    animal = employee; // Error: 'Animal' and 'Employee' are not compatible
  ```
- 构造函数也可以是 `protected`，此时它就不能直接被实例化，但可以在派生类中调用：
  ```ts
    class Person {
        protected name: string;
        protected constructor(theName: string) { this.name = theName; }
    }

    // Employee can extend Person
    class Employee extends Person {
        private department: string;

        constructor(name: string, department: string) {
            super(name);
            this.department = department;
        }

        public getElevatorPitch() {
            return `Hello, my name is ${this.name} and I work in ${this.department}.`;
        }
    }

    let howard = new Employee("Howard", "Sales");
    let john = new Person("John"); // Error: The 'Person' constructor is protected
  ```

- 参数属性，即声明和赋值都在构造函数中完成的成员属性。如果要让一个属性成为参数属性，只需要在它前面加上 `public`、 `private`、 `protected` 或 `readonly` 即可。
  ```ts
  class Octopus {
    readonly numberOfLegs: number = 8;
    constructor(readonly name: string) {  // name 就是参数属性，相当于声明了 readonly name: string; 并在构造函数中对其进行赋值
    }
  }
  ```
- 抽象类和抽象方法使用关键字 `abstract` 定义，抽象类用来作为基类供其他类继承，它本身不能被实例化。抽象类中的抽象方法只包含声明，不能被实现，且必须在派生类中去实现，即派生类必须实现每个基类的抽象方法。
- 声明一个类会创建两个东西：
  - 代表类实例的类型
  -  一个构造函数
  
  由于类创建了类型，因此可以在能够使用接口的地方用类来代替

## [Functions](http://www.typescriptlang.org/docs/handbook/functions.html)
- 如果函数没有返回值，可以使用 `void` 或者省略。
- 关于 ts 中如何在参数中指定 this 的类型以及如何提醒别人使用该方法时不应该假设 this 时可以参考 [Functions](http://www.typescriptlang.org/docs/handbook/functions.html) 中的 this and arrow functions 之后的部分
- 函数重载中，最具体的声明应该放在前面，最不具体的声明应该放在后面，下面的代码只有前两个是函数重载，第三个是函数实现：
  ```ts
  let suits = ["hearts", "spades", "clubs", "diamonds"];

  function pickCard(x: {suit: string; card: number; }[]): number;
  function pickCard(x: number): {suit: string; card: number; };
  function pickCard(x): any {
      // Check to see if we're working with an object/array
      // if so, they gave us the deck and we'll pick the card
      if (typeof x == "object") {
          let pickedCard = Math.floor(Math.random() * x.length);
          return pickedCard;
      }
      // Otherwise just let them pick the card
      else if (typeof x == "number") {
          let pickedSuit = Math.floor(x / 13);
          return { suit: suits[pickedSuit], card: x % 13 };
      }
  }

  let myDeck = [{ suit: "diamonds", card: 2 }, { suit: "spades", card: 10 }, { suit: "hearts", card: 4 }];
  let pickedCard1 = myDeck[pickCard(myDeck)];
  alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);

  let pickedCard2 = pickCard(15);
  alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
  ```