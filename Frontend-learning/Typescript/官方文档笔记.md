## [接口](http://www.typescriptlang.org/docs/handbook/interfaces.html)
- 变量用 const, 属性用 readonly
- Readonly 的元素不能赋值给其他值，如果需要赋值可以使用类型断言：`a = ro as number[];`，ro 即一个 readonly 变量
- ts 对对象字字面量会严格校验其类型, 比如在赋值或者传参时。此时可以使用类型断言 `let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);`，SquareConfig 是 `interface SquareConfig { width?: number }`
  - 但更好的方式是定义一个索引签名：
  ```ts
    interface SquareConfig {
        color?: string;
        width?: number;
        [propName: string]: any;
    }
  ```
- 定义函数类型接口：
  ```ts
    interface SearchFunc {
    (source: string, subString: string): boolean;
    }
  ```
- 字符串索引会强制所有其他属性使用它的类型：
  ```ts
    interface NumberDictionary {
        [index: string]: number;
        length: number;    // ok, length is a number
        name: string;      // error, the type of 'name' is not a subtype of the indexer
    }
  ```
  - 另外，如果将其定义为只读，则就变成了 `ReadonlyArray<T>`：
  ```ts
    interface ReadonlyStringArray {
        readonly [index: number]: string;
    }
    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
    myArray[2] = "Mallory"; // error!
  ```
- 接口只对类的公有属性进行校验，不会私有属性进行校验。
- 类实现接口时，接口只会对类的实例级属性进行匹配，而类中的构造函数属于静态属性而非实例属性，因此接口中定义的构造函数签名 `new (prop: string);` 无法与类中的构造函数进行匹配，这就导致报错。
- 接口可以继承类，它在继承类的时候只继承其声明，而不继承其实现，其中包括私有成员和保护成员。这就意味着如果你通过继承一个具有私有或保护属性的类创建了一个接口，那这个接口只能被这个类及其子类实现。因为只有其子类才具有和基类同一声明来源的属性。

## [类](http://www.typescriptlang.org/docs/handbook/classes.html)

