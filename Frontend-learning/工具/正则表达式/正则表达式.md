# 正则表达式

## 匹配基础

- 元字符 `.` 可以匹配任意单个字符，但是在绝大多数实现中，它只匹配除了换行符的单个字符（js 中也是）
- 元字符 `[]` 用来定义一个集合，在该集合中的任意字符都可能被匹配。在最前面加个 `^` 表示取反，即 `[^]` 表示不匹配该集合中的任何元素。在集合中的字符默认会当做普通字符而无需转义，但是转义也没有问题，效果一样。
- 元字符 `-` 只能用在 `[]` 里面表示区间范围，在其它地方它都只表示一个普通的 `-` 字符。如 `[0-9A-Za-z]`

| 元字符 | 含义                                                               |
| ------ | ------------------------------------------------------------------ |
| `\d`   | 类元字符，匹配一个数字，相当于 `[0-9]`                             |
| `\D`   | 类元字符，匹配一个非数字，相当于 `[^0-9]`                          |
| `\w`   | 类元字符，匹配一个字母、数字、下划线，相当于 `[0-9A-Za-z_]`        |
| `\W`   | 类元字符，匹配一个非字母、非数字、非下划线，相当于 `[^0-9A-Za-z_]` |
| `\s`   | 类元字符，匹配一个空白字符，相当于 `[\f\n\r\t\v]`，不包含 `\b`     |
| `\S`   | 类元字符，匹配一个非空白字符，相当于 `[^\f\n\r\t\v]`，包含 `\b`    |

- 十六进制： `\x`，如`\x0A` 对应 ASCII 为 10（换行符），等价于 `\n`
- 八进制： `\0`，如`\011` 对应 ASCII 为 9（制表符），等价于 `\t`

## 重复匹配

- `?` 表示匹配 0 或 1 次
- `*` 表示匹配 0 到无穷次
- `+` 表示匹配 1 到无穷次
- `{m,n}` 表示匹配 m 到 n 次
  - `{m}` 表示匹配 m 次
  - `{m,}` 表示至少匹配 m 次

默认情况下，上面的重复匹配都是贪婪模式，其非贪婪模式是在其后加个 `?`，如 `*?`、`{m,}?` 等。

## 匹配边界

- `\b` 匹配一个在能组成单词的字符（`\w`）和一个不能组成单词的字符（`\W`）之间
- `\B` 匹配一个非单词边界，如 `chosan - zhang` 使用 `\B.\B` 就能找到 `-`

- `^` 行开始，多行模式下，还匹配换行符后的位置（作为起点）
- `$` 行结束，多行模式下，还匹配换行符后的位置（作为终点）

## 子表达式

- `()` 可以表示其为子表达式

## 回溯引用

回溯的目的是保持前后匹配一致。

回溯引用即代表模式的后半部分引用在前半部分中定义的子表达式，如 `\s(\w+)\s\1`，这里的 `\1` 就代表是对前面子表达式的引用，像 `I am am Chosan` 中由于错误的输入造成两个 `am` 就可以使用这个正则匹配出 `am am`，`\n` 就代表对第 `n` 个子表达式的引用

`(?:)` 表示不捕获这个子表达式，因此就无法使用 `\1` 这种方式来引用该引用，但匹配达到的效果是一样的，只是无法回溯。

回溯引用可以替换文本，在 JavaScript 中使用 `$n` 来引用第 n 个子表达式，如 `'chosan'.replace(/(\w+)(a)(n)/, '$1e$3')`

注意：

- 回溯引用只能引用模式里面的子表达式
- 通常回溯引用以 `1` 开始。在许多实现里面，第 `0` 个匹配 `\0` 可以用来代表整个正则表达式
- 由于使用数字来引用子表达式这种情况很不稳定，一旦子表达式位置发生变化就会出现问题。因此某些实现允许使用命名捕获，格式为 `(?<captureName>pattern)`，其中的 captureName 代表捕获名，pattern 代表子表达式的匹配语法，使用命名捕获之后就可以在后面通过 `\k<captureName>` 来引用子表达式了，注意是 `\k<子表达式名称>` 的格式
- 某些实现还支持 `\E`、`\l`、`\L`、`\u`、`\U` 来进行大小写转换。但 JavaScript 中不支持。

## 前后查找

前后查找只是用来找到元素但并不在结果中返回元素的方式，比如 `<h1>chosan</h1>` 我们只希望获取到 `<h1>` 与 `</h1>` 之间的文字 `chosan`，并不希望 `<h1>` 和 `</h1>` 也返回回来，如果我们这么写正则表达式 `<h1>.*</h1>` 则匹配结果中 `<h1>` 和 `</h1>` 都会出现，我们并不希望得到这些标签，因此就需要用到前后查找。

再次重申一下，前后查找只是告诉正则表达式引擎，我需要匹配这些内容，但是我并不希望把他们也当做结果返回回来。

正向查找的模式始终是跟在 `=` 后面，负向查找相当于是对正向查找取反，但这里并不是使用 `^` 来取反，而是直接把 `=` 换成 `!`。

正向查找和负向查找都包含向前和向后，以 `http://www.chosan.cn` 举例：

- 正向向前查找 `?=`
  - 举例： 正向向前查找 `.+(?=:)` 得到 `http`，而一般的 `.+(:)` 得到的是 `http:`
- 正向向后查找 `?<=`

  - 举例： 正向向后查找 `(?<=www.).*` 得到 `chosan.cn`，而 `www(\.).*` 得到 `www.chosan.cn`

  由于 JavaScript 不支持向后查找，因此使用 php 代码测试：

```php
  <?php
    $str = "http://www.chosan.cn";
    $isMatched = preg_match('/(?<=www.).*/', $str, $matches);
    var_dump($isMatched, $matches);
  ?>
```

- 负向向前查找 `?!`
  - 相当于是对 `?=` 取反，即匹配不是子表达式中的内容，且不在结果中返回
- 负向向后查找 `?<!`

  - 相当于是对 `?<=` 取反，即匹配

- 任何一个子表达式都可以转换成一个向前查找的表达式，只需要给他加一个 `?=` 即可。向前查找可以出现在模式的任意位置，且可以使用多个向前查找
- 向前查找中的子表达式长度是可变的，即可以包含 `.` 和 `+` 之类的元字符，而向后查找模式只能是固定的，这几乎是所有正则表达式实现都遵守的限制。

## 嵌入条件

JavaScript 不支持

## 其它

- 某些实现还支持 `\c` 前缀来指定控制符，比如说 `\cZ` 匹配 `Ctrl-Z`
- POSIX 字符类，JavaScript 不支持
