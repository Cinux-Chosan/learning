本文为草稿和备份，[点这里访问 blog](https://chosan.cn/posts/5f087fa7158b3756fdd35eab)

# 正则表达式

正则表达式主要用于从一堆数据中提取具有某一特征的数据出来，当然这句话是我编的。

考虑这样一些可有可无的场景：

---

## 纯文本匹配

纯文本匹配是最简单的正则表达式匹配，可以简单理解为“文本即正则”，因为它的正则表达式几乎和文本直接对应。

考虑下面这段文本：

            Hello, my name is Chosan.

如果我们希望提取其中的 `my`，则正则表达式也为 `my`，如果我们希望提取其中的 `Chosan` 则正则表达式也为 `Chosan`。

当然，纯文本匹配是最基本的正则表达式匹配。

## 集合

集合使用 `[]` 来给出一个可以匹配的范围，即只要是集合中给出范围中的字符都可以被匹配，例如正则表达式 `[abt]` 能够匹配 `a` 中的 `a`，也能匹配 `boss` 中的 `b` 或者 `city` 中的 `t`，但是无法匹配 `new` 中的任意字符，因为 `new` 中没有一个字符是属于集合 `[abt]` 之一。

### 连字符 `-`

**集合的目的是给出一个能够匹配的范围**，如果我们需要表示所有的小写字母，使用 `[abcdefghijklmnopqrstuvwxyz]` 虽然也能达到目的，但是这样做未免过于繁琐，因此在集合中可以使用 `-` 来连接范围的开始和结束，举两个例子：

- `[a-z]` 表示匹配所有的小写字母，即从 `a` 开始到 `z` 结束，
- `[0-9A-Za-z]` 给出的集合包含 0 到 9 的数字、所有大写字母以及小写字母。

### 取非

如果我们已知集合 `[abc]`，我们希望匹配除了 `abc` 之外的字符需要怎么做呢？我们没办法列出所有 `abc` 之外的字符来。

要解决这个问题，就需要使用到集合中的 `^` 元字符了。这个字符出现在集合的开始位置，表示所有出现在集合中的元素都不能被匹配。举个例子：

- `[^abc]` 表示除了 `abc` 之外的字符，它能够匹配到 `cat` 中的 `t` 但是不能匹配到 `c` 和 `a`

### 预定义字符

我们经常会用到诸如 `[0-9a-zA-Z_]` 这类的集合，因此为了写起来简便，正则表达式中预定义了一些字符：

| 元字符 | 含义                                                                  |
| ------ | --------------------------------------------------------------------- |
| `\d`   | 表示 0 到 9 的数字，即等同于 `[0-9]`                                  |
| `\D`   | 对 `\d` 取反，表示匹配任何一个非数字，等同于 `[^0-9]`                 |
| `\w`   | 匹配一个字母、数字或者下划线，等同于 `[0-9A-Za-z_]`                   |
| `\W`   | 对 `\w` 取反，相当于 `[^0-9A-Za-z_]`                                  |
| `\s`   | 匹配一个空白字符，相当于`[\f\n\r\t\v ]`，不包含 `\b`                   |
| `\S`   | 对 `\s` 取反，即匹配一个非空白字符，相当于 `[^\f\n\r\t\v]`，包含 `\b` |

上面是一些常用的预定义字符，我们可以看到大写的元字符实际上就是对小写元字符的**取非**操作，实际上正则表达式中的元字符普遍也满足这个规律。

有了上面那些预定义的集合类元字符可以大大的节省了我们写正则表达式的时间。其中 `\s` 中的每一个字符分别代表：

- `\f`：换页符
- `\n`：换行符
- `\r`：回车符
- `\t`：制表符（Tab 键）
- `\v`：垂直制表符
- ` `：空格

## 匹配任意字符

有时候我们并不希望只匹配固定的文本，而是希望匹配任意字符，举个例子：用户输入了一段文字，我们希望拿到这段文字的第一个字符。这要怎么办呢？

显然，我们无法再使用像纯文本匹配那样的正则表达式，因为我们根本不清楚用户会输入什么内容！

要解决这个问题，就需要使用到正则表达式中的元字符 `.` 了，它几乎可以**匹配任意字符**。如果用户输入的是 `Chosan`，则 `.` 匹配到的内容就是第一个字符 `C`，如果用户输入的是 `+-*/` 则 `.` 匹配的内容就是第一个字符 `+`。

这里需要注意的是，`.` 并不是只能匹配第一个字符，而是因为一个 `.` 只能代表一个字符，因此它优先匹配到了文本中第一个字符而已。同理，如果我们希望获取前两个字符，使用正则表达式 `..` 即可。

> 小提示：在大多数的正则实现中，`.` 都只匹配除了换行符之外的单个字符。

### 转义

元字符 `.` 匹配任意字符，要是我们就希望匹配文本中的 `.` 怎么办呢？在正则表达式中，如果要匹配元字符，则需要使用 `\` 对元字符进行转义，举个例子，如果我们希望匹配域名 `tcn.cn` 中的 `.cn` 部分，就需要使用正则表达式 `\.cn` 了，否则如果使用 `.cn` 则首先会匹配到 `tcn` 而非我们想要的 `.cn`。

## 重复匹配

前面我们使用了 `..` 来匹配一段文本的前两个字符，如果我们要匹配前 100 个字符怎么办呢？显然连续写 100 个 `.` 这种做法是不合常理的，即便你认为它勉强符合常理，1000 个、10000 个总不符合常理了吧。

因此，重复匹配就诞生了。正则表达式给我们提供了以下几种重复匹配的元字符：

- `?`：匹配 0 个或一个字符，
  - 举例： `os?` 可以匹配 `boss` 中的 `os`，`coat` 中的 `o`，因为 `s` 可以出现 0 次或 1 次
- `+`：匹配 1 次以上
  - 举例： `os+` 可以匹配 `boss` 中的 `oss`，`ios` 中的 `os`，但不能匹配 `bob` 中的 `o`，因为 `s` 至少要出现 1 次以上
- `*`：匹配任意次，即 0 到无限次
  - 举例： `os*` 可以匹配 `boss` 中的 `oss`，`ios` 中的 `os` 以及 `bob` 中的 `o`，因为 `s` 可以出现任意次数
- `{m,n}`： 匹配 m 到 n 次
  - 举例： `os{2,4}` 可以匹配字符串 `boss` 中的 `ss`，`bosss` 中的 `sss` 以及 `bossss` 中的 `ssss`，如果出现更多（大于 4 个）连续 `s` 也最多匹配前 4 个连续 `s`，但是无法匹配 `bos` 中的 `s`

上面的集中模式看似已经很圆满了，但是还有一些场景无法覆盖，比如：

- 仅匹配 `m 次`
- 匹配 `m 次以上`

由于 `?` 要么匹配 0 次要么匹配 1 次，`+` 表示至少 1 次， `*` 表示任意次数。都无法指定到特定的某个次数上，因此 `{m,n}` 这种写法还有另外两个衍生模式：

- `{m}`：匹配 m 次
  - 举例：`os{1}` 能够匹配 `boss` 中的 `os`，`os{2}` 能匹配 `boss` 和 `bosss` 中的 `oss`，但无法匹配 `bos`，因为 `s` 需要连续出现两次
- `{m,}`：匹配 m 次以上
  - 举例：`os{2,}` 能够匹配`boss` 中的 `oss` 以及 `bosss` 中的 `osss`，但无法匹配 `bos`

### 懒惰（非贪婪）

你似乎没有注意到一个问题（或者你已经注意到了），上面的重复匹配始终都是以最多次进行匹配。

换句话说，`o*` 匹配出 `good` 中的 `oo` 以及 `gooood` 中的 `oooo`。

你可能觉得这很正常，毕竟我们说了 `*` 表示匹配任意次，即 0 到 无穷次，所以上面的匹配完全没问题呀！

是的，它的确没有问题，但既然 `*` 表示 0 到 无穷次，那为什么不是匹配到 0 次就停止，或者为什么不是只匹配 1 次就停止呢，0 和 1 也在 \* 表示的范围中呀！

这是因为默认情况下，重复匹配都是**尽可能多**的匹配，能匹配 10 个就绝不只匹配 9 个，有 100 个就绝对不只匹配 99 个！由于这种模式很贪婪，因此在正则表达式中也被称作**贪婪模式**！

贪婪模式有贪婪模式的好处，但并不是所有情况我们都希望它那么贪婪。考虑如下文本：

            <p>我很<em>贪婪</em>，你来<em>打我</em>呀!</p>

如果此时我们希望获得第一个 `<em>` 的完整内容，我们可能会这么写正则表达式 `<em>.*<\/em>`。我们期望它能够帮我们匹配出字符串 `<em>贪婪</em>`。但实际并非如此，由于 `.` 可以匹配任意字符，`*` 默认情况下又是贪婪模式，因此 `<em>.*<\/em>` 实际上匹配到了 `<em>贪婪</em>，你来<em>打我</em>`，即第一个 `<em>` 开始到第二个 `</em>` 结束。这是你想要的吗？

显然不是，并且更加显然的是，我们肯定不希望它那么贪婪，我们希望它更加懒惰！能尽可能少的匹配就别匹配那么多，只要刚刚好！

正则表达式也为我们考虑到了这种情况，能尽可能少的匹配这种模式叫**懒惰模式**，也叫**非贪婪模式**。

懒惰模式的方法是在重复匹配的元字符后面加一个 `?`，举个例子：

- `*` 是贪婪模式，`*?` 就是非贪婪模式
- `+` 是贪婪模式，`+?` 就是非贪婪模式
- `{m,}` 是贪婪模式，`{m,}?` 就是非贪婪模式

举个实在点儿的例子，还是这段文本：

            <p>我很<em>贪婪</em>，你来<em>打我</em>呀!</p>

我们使用之前是使用 `<em>.*<\/em>` 来匹配，但是未能如我们所愿，因此我们使用懒惰模式 `<em>.*?<\/em>`，这下就匹配成功了，它帮我们匹配出了 `<em>贪婪</em>`，这正是我们想要的。

选择贪婪和非贪婪，应视情况而定。

## 边界匹配

### 单词边界 `\b`

考虑这样一种情况，假设我们希望提取出一段文本中的单词 `you`，因此我们写了一个正则表达式 `you` 希望它能够帮我们达到目的，但事实真的如此吗？

举个例子：

            you are so young!

上面这段文本使用正则表达式 `you` 确实能帮你匹配到单词 `you`，但是如果是下面这段文本呢？

            your coat is nice! —— thank you!

如果再使用正则表达式 `you` 来匹配那就不行了，因为它首先会匹配到单词 `your` 的前三个字母 `you`，很明显这不是我们想要的，我们想要的是匹配文本中的单词 `you` 而不是一个含有 `you` 的单词片段。

要解决这个问题，就需要用到正则表达式中的边界匹配了。

单词的边界使用 `\b` 来表明，准确的来说它是匹配一个在能组成单词的字符（`\w`）和一个不能组成单词的字符（`\W`）之间。

继续以上面的例子为例，我们需要匹配出文本中的单词 `you`，现在可以用正则表达式 `you\b` 来指明单词的边界，针对上面两段文本，它都能正确的匹配出单词 `you` 来，但它不够严谨，因为这种只顾屁股不顾头的做法遇到 `tayou` 之类的单词就 GG 了，因此更加严谨的写法是前后都加上单词边界 `\byou\b`。

`\B` 与 `\b` 正好相反，它匹配一个非单词边界，如 `hard - working` 使用正则表达式 `\B-\B` 就能找到其中的 `-`，但如果连起来写 `hard-working` 就无法匹配了。

### 字符串边界 `^` 与 `$`

聊完了单词边界，我们来看看字符串边界。

当用户随机输入了一段文字之后，我们希望用正则表达式来校验其是否是以 `Hi,` 打头，以 `Bye!` 结尾。我们要怎么做呢？

你可能首先会想到正则表达式 `Hi,.*Bye!` ，如果这样那你就 too naive 了！

因为上面的正则表达式对下面这段本文是无法达到预期效果的：

            Emm... Hi, Lucy ... blablabla ... Bye! —— See you!

对于这段文本，上面的正则表达式只能匹配出其中从 `Hi,` 开始到 `Bye!` 这一段内容，并不能知道整段内容是否是以 `Hi,` 打头并且以 `Bye!` 结尾。

因此我们需要指定匹配的边界！即 `Hi,` 必须要出现在文本最前面，`Bye!` 必须出现在文本最后面！庆幸的是正则表达式已经有预定义字符可以帮助我们来标记对应的位置了：

- `^`：匹配文本的起始位置
- `$`：匹配文本的末尾位置

`^` 我们前面已经见过了，但那是在集合最前面的位置，表示对集合取非。但现在它如果出现在正则表达式的开头，那就表示需要匹配文本的起始位置了。举个例子：

`^Hi` 能匹配单词 `High` 或者字符串 `Hi, my name is Chosan.`，因为他们都是以 `Hi` 打头，但无法匹配 `Hello —— Hi`，因为它不是以 `Hi` 开头的。

同理 `$` 表示字符串结尾的位置，因此 `Bye$` 可以匹配 `Good Bye` 但是无法匹配 `Bye, My Dear!`，因为后者的 `Bye` 不是出现在句子的末尾！

回到本节最开始的那个问题上，我们要校验文本是否是以 `Hi,` 打头，以 `Bye!` 结尾，我们可以这么来写正则表达式：`^Hi,.*Bye!$`

## 取或操作

- `|` 表示取或，如 `first|1st` 表示既可以匹配 `first` 也可以匹配 `1st`，而 `[]` 只能是匹配其中的单个字符

## 分组（子表达式）

考虑这样一种情况：我们希望匹配表达式中的连续 10 个 Hi，这段文本内容如下：

            Hi Hi Hi Hi Hi Hi Hi Hi Hi Hi

用我们前面讲到的内容，能完成吗？

除了想到写一个纯文本匹配的表达式，我几乎想不出来需要怎么做，即便是我们学了重复匹配，也无法写出来，因为正则表达式 `Hi\s{10}` 表示的是`1 个 Hi + 10 个空白字符` 而非 10 个 `Hi\s`。

难啊~

好在，正则表达式有分组的概念，即子表达式。

子表达式将其内容放在 `()` 之间，从而**形成一个更大的独立个体**！与原来的区别是，正则表达式 `abc` 中的每个字符都是一个个体，我们使用重复匹配也只能针对单个字符来编写，即便是使用集合的概念，每个集合也只代表了能匹配集合中的一个元素。比如：

- `abc+`：重复匹配元字符 `+` 表示 `c` 至少出现 1 次，但无法同时控制 `a` 和 `b`
- `a[bc]+`：重复匹配元字符 `+` 表示 `b` 或 `c` 至少出现 1 次，但并非 `b` 和 `c` 同时出现至少 1 次

子表达式应运而生！

如果我们要将 `bc` 组成一个个体，那就可以写成 `a(bc)`，如果此时再加上重复匹配元字符 `+`，那么 `a(bc)+` 代表的意思就是 `a 加 1 到无穷个 bc`。

回到前面的问题，如果我们要匹配 10 个连续的 `Hi\s`，我们只需要写这样的正则表达式：`(Hi\s){10}` 即可。

### 捕获与非捕获

---

#### 捕获组

默认情况下，分组是捕获的。什么意思呢？

举个例子，在正则表达式 `(\d+)\.(.+)` 中，`(\d+)` 是第一个分组，`(.+)` 是第二个分组，它们会被正则表达式引擎记录下来，以便后续通过 `$n` 的方式来访问第 `n` 个捕获组。以 JavaScript 代码为例：

```js
var str = "99. Hi, this is Charpter 99";
str.match(/(\d+)\.(.+)/);
RegExp.$1; // "99"
RegExp.$2; // " Hi, this is Charpter 99"
```

#### 非捕获组

在某些情况下，我们只需要分组参与匹配，而后续并不会使用到该分组，因此不需要记录对应的分组，我们就可以将其写作非捕获的方式。

非捕获告诉正则引擎这个分组不用捕获，也就是只匹配不记录。非捕获的形式为 `(?:)`，其中以 `(?:` 开始一个非捕获组，以 `)` 结束分组，中间是分组内容。它与捕获分组的区别就在于分组前面加了 `?:` 而已。我们试试非捕获分组：

```js
var str = "99. Hi, this is Charpter 99";
str.match(/(?:\d+)\.(.+)/);
RegExp.$1; // " Hi, this is Charpter 99"
RegExp.$2; // ""
```

由于我们指定了第一个分组为非捕获组，因此正则引擎就只让该分组参与匹配，但不记录该分组结果。第二个分组不是非捕获组，因此它是第一个被记录的分组，通过 `$1` 来获取其匹配内容，而此时 `$2` 没有对应的引用分组，所以没有内容。

#### 替换文本

正则表达式强大的功能之一就是替换匹配的文本。结合捕获组可以使得文本替换变得更加强大！

比如说有如下文本：

            Hello, Lucy, I'm Chosan.

此时我们需要将 Lucy 和 Chosan 兑换位置，也就是相互替换。我们需要怎么做呢？

刚刚我们已经知道捕获会被正则表达式引擎记录，然后通过 `$n` 的方式引用第 `n` 个捕获组，因此我们可以将 `Lucy` 和 `Chosan` 分别捕获起来，正则表达式为 `(Lucy)(.*)(Chosan)`，以 JavaScript 代码举例：

```js
var str = "Hello, Lucy, I'm Chosan.";
str.replace(/(Lucy)(.*)(Chosan)/, "$3$2$1"); // "Hello, Chosan, I'm Lucy."
```

其中，`replace` 方法第二个参数中的 `$n` 就是对其第一个参数指定的正则表达式中捕获组的引用。

### 回溯引用

回溯引用的意思是**在同一个正则表达式中引用出现在前面的分组**。

举个例子，有如下文本：

            看看<em>回溯</em>怎么用

如果我们需要匹配 `<em>` 到 `</em>` 的这一段内容，我们需要怎么做？

针对上面这段文本，`<em>.*?<\/em>` 是可以的。但是我们发现 `em` 实际上是重复劳动力，你可能觉得这并无大碍，但在实际场景中，很有可能我们要匹配的并非一个特定的 `em` 标签，而是一个未知标签，因此我们可能定义了这样一个通用的正则表达式来匹配标签名：`[A-Za-z][\w]*\s*`，然后使用这个通用正则表达式来做上面的匹配工作：`<[A-Za-z][\w]*\s*>.*?<\/[A-Za-z][\w]*\s>`，同一个表达式在前后都用到了，并且同时还存在好几个问题：

- 虽然能匹配 `<em>` 到 `</em>` 的整段内容，但如果是一段不合法的 html 片段 `<em>回溯</p>` 同样能匹配成功。
- 写法太过于冗余，重复累赘不直观！
- 其它问题

怎么解决上面的问题呢？分析一下可以知道：

> 我们实际上是需要前后保持一致，即前面匹配的开标签是 `<em>`，那后面的闭合标签就一定要是 `</em>`，如果前面的开标签是 `<span>`那闭合标签就一定要是对应的 `</span>`，否则就匹配失败。

回到实际场景，如何去解决这个问题呢？这就涉及到回溯引用，如本节开头说的那样 —— 回溯引用就是引用前面的分组。

好了，分组是逃不掉的，我们先将开标签部分进行分组以便后续引用，将 `<[A-Za-z][\w]*\s*>` 改成 `<([A-Za-z][\w]*\s*)>`，这样我们就有了 1 个分组，此时我们需要在闭标签的地方引用开标签中匹配的内容，怎么做呢？

使用 `\1` 来引用第一个分组，它表示这里的内容必须要和前面对应分组匹配的内容完全一致。因此上面完整的表达式为：`<([A-Za-z][\w]*\s*)>.*?<\/\1>`。

其中 `\1` 就是回溯引用第一个分组，如果有多个分组，则 `\n` 就是引用第 `n` 个分组，注意 `n` 是个变量，不要和元字符 `\n` 混淆。

好了，此时的正则表达式 `<([A-Za-z][\w]*\s*)>.*?<\/\1>` 就能够满足我们的需要了，即开标签中匹配什么内容，闭标签中就匹配同样的内容，如：

            看看<em>回溯</em>怎么用

能够匹配成功，而：

            看看<em>回溯</p>怎么用

就不能匹配成功。

而且此时还不用重复写过多的表达式。

### 分组命名

在上面回溯引用的例子中我们可以看到，通过 `\1` 去引用第一个分组的形式虽然看似简单，但不直观，在只有一两个分组的情况下还好，万一分组太多并且嵌套，就很难一眼看出`\n` 到底引用的第 `n` 个分组是什么了。举个例子：`<([A-Za-Z]-([\w]*))(\s*([A-Za-z:@]))*>.*\4\3\1\2` 这个正则表达式里面如果你需要找到第四个分组，你就需要一个一个分组的挨着找，并不能一眼就定位到某个分组的具体位置，另外，如果分组位置变了，整个正则还得重新修改对前面位置的引用。

因此，正则表达式支持**分组命名**。

分组命名的格式为 `(?<groupName>)`，其中分组以 `(?<groupName>` 开始，以 `)` 结尾，中间就是分组的正则表达式内容，举个例子：

正则表达式 `(?<tagName>[A-Za-z][\w]*\s*)` 就表示我们定义了一个分组，其名称为 `tagName`，其内容为 `[A-Za-z][\w]*\s*`。

定义好了分组名称之后，我们就可以在后面直接通过`\k<名称>` 的方式来引用具名分组，因此之前回溯部分的示例 `<([A-Za-z][\w]*\s*)>.*?<\/\1>` 可以通过命名分组定义为： `<(?<tagName>[A-Za-z][\w]*\s*)>.*?<\/\k<tagName>>`。现在一眼就能定位到 `tagName` 分组定义在什么位置，在有较多分组或者表达式可能经常需要改变分组位置的时候，给分组命名是很有帮助的。

## 前后查找（正反查找 或 零宽断言）

考虑这样一种情况

            <h2>look ahead</h2>

我们希望提取出 `<h2>` 和 `</h2>` 之间的内容，但并不希望 `<h2>` 和 `</h2>` 也包含在结果中。怎么做呢？

除了借助特定的编程语言，在正则表达式中，我们可以使用**前后查找**！

前后查找分为向前查找和向后查找。

向前查找就是站在某个位置向前看，向后查找就是站在某个位置向后看！这个位置已经被你踩在脚下，因此这个位置是看不见的（它在你脚底），但是这个位置存不存在呢？想啥呢，当然存在！写个代码你还想遁入虚空之门呢？！

### 向前查找

向前查找就是给定一个位置，查找在其前面的内容并返回结果。但这个位置的内容并不希望返回，它只做匹配用，换句话说，它只是个 “工具人”！

向前查找使用 `(?=)`，其中以 `(?=` 开始，以 `)` 结束，中间就是我们用来 “站” 的位置，如 `x(?=y)` 表示的就是如果 `x` 后面是 `y` 就表示 x 匹配成功，我们来看个例子吧！

            <h2>look ahead</h2>

现在，我们站在 `</h2>` 的位置向前查找，我们写出正则表达式 `.*(?=<\/h2>)`，它匹配出在 `</h2>` 前面的内容并返回，即 `<2>look ahead`，返回结果中并不包含 `</h2>` 本身。

这就是我们所谓的站在 `</h2>` 的位置向前看！

### 向后查找

向后查找就是给定一个位置向后看，所见即所得。

向后查找使用 `(?<=)` 的格式，以 `(?<=` 开始，以 `)` 结束，中间就是我们 “站” 的位置，如 `(?<=y)x` 表示如果 `x` 前面是 `y` 表示 `x` 被匹配成功。

还是向前查找中的例子为例：

            <h2>look ahead</h2>

我们要获取 `<h2>` 后面的内容，咋做呢？

参照向后查找的格式，我们写出正则表达式 `(?<=<h2>).*`，它返回的匹配结果为 `look ahead</h2>`。

这就是我们所谓的站在 `<h2>` 的位置向后看！

### 前后并用

回到我们在本章最初提出的问题，我们希望提取以下文本中 `<h2>` 和 `</h2>` 之间的内容：

            <h2>look ahead</h2>

刚学完前后查找，很快就能用上了。

`<h2>` 和 `</h2>` 之间的内容实际上就是站在 `<h2>` 向后看和站在 `</h2>` 向前看的内容交集，我们以此目标来写出这样一个正则表达式：`(?<=<h2>).*(?=<\/h2>)`，它返回的结果就是 `look ahead`，即刚好是 `<h2>` 和 `</h2>` 之间的内容，我们还可以搭配上前面的回溯，给标签个命名 `/(?<=<(?<tag>h2)>).*(?=<\/\k<tag>>)/`。

### 取非

前面我们说的前后查找的方式被称为 “正反查找”，其包含“正向查找” 和 “反向查找”。

其实正反查找还可以`取非`操作，它的写法就是把 “正向前后查找” 中的 `=` 替换为 `!`，原来是前后如果是对应的元素则匹配成功，`取非`之后表示前后不是对应的元素才匹配成功：

- 正向查找 `(?=)`：如 `x(?=y)` 表示如果 x 后面跟着 y 就匹配成功
- 正向否定查找 `(?!)`：`(?=)` 的否定形式，如 `x(?!y)` 表示如果 x 后面不是 y 则匹配成功
- 反向查找 `(?<=)`：如 `(?<=y)x` 表示如果 x 前面是 y 则匹配成功
- 反向否定查找 `(?<!)`：`(?<=)` 的否定形式，如 `(?<!y)x` 表示如果 x 前面不是 y 则匹配成功

## 修饰符

通用修饰符一般包含：

- `i`：忽略大小写
- `g`：全局匹配
- `m`：多行匹配
- `s`：单行匹配

具体使用方式和实现有关，比如 JavaScript 中将修饰符放在正则表达式字面量末尾的 `/` 之后，如 `/.*/i`。

### `i`

修饰符 `i` 是 `ignore` 的意思，它的作用表示匹配时忽略大小写。举个例子：

一般情况下，正则表达式是大小写严格的，意味着 `my` 只能匹配字符串 `my`，不能匹配 `My`、`MY` 以及 `mY`。但经常我们并不关心大小写，因此可以使用 `i` 修饰符。

### `g`

修饰符 `g` 是 `global` 的意思，它表示搜索全局文本。举个例子：

默认情况下，正则表达式匹配到第一项就退出。但是一段文本中可能包含许多可以匹配的项，比如

            today, it's raining

我们希望找出所有的字符 `t`，但正则表达式 `t` 只能匹配到第一项就停止了，如果我们想要匹配所有的 `t`，就需要使用修饰符 `g`，它会找出所有满足正则表达式的文本，而非只找出一个就停止了。

### `m`

修饰符 `m` 是 `multiLine` 的意思，即多行匹配。它会影响 `^` 和 `$` 的具体含义。

默认情况下，`^` 只能匹配文本的开头，`$` 只能匹配文本的结尾。如果文本有多行的情况下也是如此。但有时候我们希望 `^` 表示每一行的开头，`$` 表示每一行的结尾，举个例子：

               Yesterday is Monday
                Today is Tuesday
                Tomorrow is Wednesday

这是一个多行文本，我们希望匹配以 `T` 打头并且以 `day` 结尾的行，需要怎么做呢？

`^T.*(day)$` 并不能达到我们的目的，因为：

- `^` 表示文本的开头，即上面的 `Y` 前面的位置，但是正则表达式中指定文本开头为 `T`，匹配失败！
- `$` 表示文本的结尾，即 `Wednesday` 单子后一个位置，单看这个条件好像没问题。但 `.` 默认情况下是匹配除了换行符 `\n` 以外的字符。因此这个正则表达式根本走不到文本的最后就被拦下来了。因此也匹配失败！

这个时候修饰符 `m` 就起作用了！ `m` 表示多行匹配，它会改变 `^` 和 `$` 的具体含义：

- `^` 出现在正则表达式开头表示匹配整个文本的起点，使用了 `m` 之后 `^` 可以表示每一行的开头
- `$` 出现在正则表达式的末尾表示匹配整个文本的末尾位置，使用 `m` 之后 `$` 可以表示每一行的末尾位置

现在我们给前面的正则表达式加上修饰符 `m`，以 JavaScript 代码为例：

```js
var str = `Yesterday is Monday
Today is Tuesday
Tomorrow is Wednesday`;
str.match(/^T.*(day)$/m);
```

得到匹配结果：`"Today is Tuesday"`，如果我们要匹配所有以 `T` 开头并且以 `day` 结尾的行，可以加上前面提到的 `g` 修饰符表明我们要全局搜索。

### `s`

修饰符 `s` 具有 `singleLine` 的意思，某些地方也称作 `dotAll`，即单行模式。如同 `m` 影响 `^` 和 `$` 的具体含义一样，`s` 影响 `.` 的具体含义。

默认情况下，`.` 不会匹配换行符 `\n`，加上 `s` 修饰符之后 `.` 才是真正的匹配任意字符，包括 `\n`。

## 一些常用的正则

## 后记

如有任何错误或改进的地方，欢迎留言指正。
