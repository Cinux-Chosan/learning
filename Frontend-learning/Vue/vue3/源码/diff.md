# Vue3 diff

vue3 中，diff children 分为两种情况，带 `key` 的和不带 `key` 的

命名规定：

- `c` 开头代表 children，如 c1 代表旧子节点列表，c2 代表新子节点列表；
- `n` 开头代表 node，即 n1 代表 c1 中的元素， n2 同理；
- `s` 开头代表 start，即起始坐标，如 s1 代表该变量表示在 c1 中的某个索引，s2 同理；
- `e` 开头代表 end，即结束坐标，如 e1 表示在 c1 中的结束位置，e2 同理

不带 `key` 的使用 `patchUnkeyedChildren` 方法，该过程比较简单：

- 取两者长度较小值 `Math.min(c1.length, c2.length)` 为 `commonLength`
- 直接 `for` 循环 `commonLength` 次，直接挨个 `patch` 每个位置对应的节点
- 如果
  - **旧的子节点长度 `>` 新的子节点长度**，则直接 `unmount` 从 `commonLength` 之后的元素
  - 否则说明新的子节点比旧的子节点多，`mount` 从 `commonLength` 之后的元素

带 `key` 的使用 `patchKeyedChildren` 方法

- 从最开始对比两个数组中的 VNode，如果是同一类型的则直接 `patch` 并将位置索引 `i` 进行 `+1`，否则退出循环，此时对比到第 `i` 个元素
- 从最后开始对比两个数组中的 VNode，如果是同一类型则也是直接 `patch` 并每次数组长度 `-1`，否则退出循环，
- 如果：
  - 旧节点已经比对完，新的节点还有剩余，则 `mount` 新的节点
  - 新的节点已经对比完，旧的节点还有剩余，则 `unmount` 旧的节点
  - 新旧都存在未比对的元素（首尾都已经对比完成，因此未对比的元素仅会在中间）：
    - 将所有新的节点以 `key => index` 的方式记录到 map 结构 `keyToNewIndexMap` 中
    - 遍历剩下的旧的节点（即首尾对比完后中间的所有旧节点）
      - 如果：
        - 节点存在 `key`，则直接从 `keyToNewIndexMap` 中取出（对应 `key`）新的下标 `newIndex`
        - 不存在 `key`，则遍历新的节点，看是否可以找到一个类型匹配的节点，记录其下标为 `newIndex`
      - 如果
        - 不存在 `newIndex` 则直接 `unmount` 旧的节点
        - 存在，则 `patch` 两个节点（即当前的 `n1` 和 `c2[newIndex]`），并记录新节点下标对应的旧节点下标到 `newIndexToOldIndexMap` 数组，同时用布尔变量 `moved` 记录是否有节点移动了位置
      - 如果新节点已经全部都被 `patch` 过，则剩下的旧节点全部 `unmount`
    - 遍历剩下的新节点（即首尾对比完后中间的所有新节点）
      - 如果：
        - 新节点不存在对应的旧节点（通过之前记录的 `newIndexToOldIndexMap` 数组判断），则直接 `mount` 新节点
        - 移动了位置（通过 `moved` 布尔变量判断）
          - 如果
            - 不存在最长上升子序列或者元素不在该序列中（通过 `newIndexToOldIndexMap` 获得最长上升子序列，**最长上升子序列的作用是减少节点移动的次数**，_因为它代表了按升序排列的最长的未处理新节点，只要存在于该序列中的元素都可以保持原有位置，让那些不存在该序列中的元素来移动位置即可_），则移动节点
            - 否则，元素存在于最长上升子序列中，则不移动
